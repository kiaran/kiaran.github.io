{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Power IK Documentation Welcome to the Power IK official documentation. Power IK comes in two flavors, an Unreal Plugin and a C++ SDK for integration into other software or game engines. This documentation includes information for both. To see Power IK in action visit poweranimated.com . Please report any issues or errors to support@poweranimated.com What is Power IK? Power IK is a full-body inverse kinematics solver that lets animators push and pull skeletons to dynamically and procedurally modify poses. How Is It Different? A normal IK solver operates on a single chain of joints by pulling them towards a single point in space. But with Power IK, the solver affects the entire skeleton with as many effectors as you like. With Power IK, effectors are associated with a joint in your skeleton. When you move the effectors, Power IK figures out how your skeleton should move to reach all of them at once. The final pose is the best compromise between all the competing effectors. If an effector is within reach, Power IK will reach it. If effectors cannot all be simultaneously reached, Power IK positions the skeleton evenly between them. If effectors are squashed towards each other, PowerIK will squish the bones into a smooth shape. Natural Poses There are many different possible poses that reach the same effectors; sometimes infinite. But Power IK attempts to achieve the most natural looking pose which is characterized as having smooth lines free from kinks; while distributing the motion across the whole body. This is the same as minimizing the \u201cenergy\u201d of the pose, which is what real-world creatures tend to do.","title":"Home"},{"location":"#power-ik-documentation","text":"Welcome to the Power IK official documentation. Power IK comes in two flavors, an Unreal Plugin and a C++ SDK for integration into other software or game engines. This documentation includes information for both. To see Power IK in action visit poweranimated.com . Please report any issues or errors to support@poweranimated.com","title":"Power IK Documentation"},{"location":"#what-is-power-ik","text":"Power IK is a full-body inverse kinematics solver that lets animators push and pull skeletons to dynamically and procedurally modify poses.","title":"What is Power IK?"},{"location":"#how-is-it-different","text":"A normal IK solver operates on a single chain of joints by pulling them towards a single point in space. But with Power IK, the solver affects the entire skeleton with as many effectors as you like. With Power IK, effectors are associated with a joint in your skeleton. When you move the effectors, Power IK figures out how your skeleton should move to reach all of them at once. The final pose is the best compromise between all the competing effectors. If an effector is within reach, Power IK will reach it. If effectors cannot all be simultaneously reached, Power IK positions the skeleton evenly between them. If effectors are squashed towards each other, PowerIK will squish the bones into a smooth shape.","title":"How Is It Different?"},{"location":"#natural-poses","text":"There are many different possible poses that reach the same effectors; sometimes infinite. But Power IK attempts to achieve the most natural looking pose which is characterized as having smooth lines free from kinks; while distributing the motion across the whole body. This is the same as minimizing the \u201cenergy\u201d of the pose, which is what real-world creatures tend to do.","title":"Natural Poses"},{"location":"sdk/change_log/","text":"Official Power IK Change Log Added: new features. Changed: changes in existing functionality. Deprecated: soon-to-be removed features. Removed: now removed features. Fixed: any bug fixes. [1.52] - 2020-AUG-02 Added: New Body Inertia setting in core solver (with Smooth and Spring modes) Added: Body Inertia settings to Ground Node, Walk Node, Solver Node and Control Rig node Added: Explicit control over final iteration count in solver (exposed on all nodes) Fixed: Ground Node double transform on body when using PullWeights and MoveRoot slope setting Changed: Walk Node, does not continuously update target plant location (avoids jitter stepping on uneven terrain) Changed: Ground Node, slope setting \"Push Feet Outer\" supports negative values Changed: Walk Node, stepping parameters exposed as pins Changed: Walk Node, removed clamp on walk parameters Changed: Walk Node, limb struct can be made with blueprint and all properties modified at runtime Changed: Walk Node, only prints teleport warning when \"PrintTeleportWarning\" is true for debugging [1.51] - 2020-JUL-01 Added: New Anim Graph node! \"Power IK Walk\" node creates procedural locomotion Added: New Core Solver upgrade efficiently produces more accurate and believable reaching Fixed: Bug in Core Solver; sub-root weights incorrect when Character Root was max distance from Effector Fixed: Bug in Core Solver; Bend Directions not respected when squash caused by sub-root rotation Changed: Ground Node's Delta Smooth Speed property exposed as a pin Removed: Power IK Rig Component (deprecated last release, use Control Rig now) Removed: PowerIK_Funcs blueprint function library (only needed for Rig component) [1.50] - 2020-JUN-08 Added: New Power IK Control Rig integration Added: New Power IK Ground Node, dedicated node for simpler ground setup Added: New Pole Vector support on Power IK Effectors Added: New PowerIK_UnrealCore.h system to make building your own nodes easier Added: New Debug drawing of ground raycast hit points and color coded rays Removed: \"IsGrounded\" bool from Power IK Effector (use Ground node now) Changed: Pos/Neg Pull Factor default on Ground node set to 0, 0, 1 Changed: All \"grounded\" examples now use Power IK Ground node Changed: \"JointLimits\" renamed \"BoneLimits\" for consistency Fixed: Massive refactor of SDK and Plugin code to support rapid development Fixed: Bug in core solver, effectors on inner forks did not squash limbs correctly Deprecated: The Power IK Interactive Rig component (use Control Rig now) [1.48] - 2020-MAY-31 Added: SDK interface for adjusting skeleton before solve is run Added: SDK sample of procedural skeleton adjustment Added: SDK math functions MoveTowards, RotateTowards and PitchYawDecompose w/ comments Fixed: Bug, static foot offset did not follow foot normal Fixed: Bug, ground foot rotation was doubled up if RotateBone was off Changed: Default slope adjustment speed from 75 to 150 Changed: Ground alignment code removed from core solver Removed: IsGrounded flag from interactive rig component, didn't make sense & had bugs [1.47] - 2020-MAY-24 Fixed: Bug in core solver, effectors not keeping bones 100% stable Changed: Code cleanup in SDK [1.46] - 2020-MAY-18 Added: Support for Linux platform (multiplayer Linux servers) Added: Support for Unreal 4.25 Added: Separate position/rotation spaces on effectors Added: Changelog in docs Added: Docs better describe installation for Engine vs Project Fixed: SDK compiles warning free on clang and MSVC compilers Fixed: Packaging script removes potentially stale POWERIK.dll Added: Packaging script adds Changelog to docs Changed: Packaging script copies Changelog and License to top level folder Removed: (SDK) IsAdditive option on SetEffectorTransform(), assumes Component Space now [1.45] - 2020-MAY-02 Added: \"Exclude Bones\" list on solver to remove bones from skeleton Fixed: packaging error when plugin installed in engine folder saying \"PrecompileForTargets\" Added: Error reporting in all SDK function return values Changed: SDK solver code modularized further [1.44] - 2020-MAY-01 Fixed: plugin now works in precompiled mode (outside project) Fixed: compile errors in plugin when not using precompiled headers Fixed: critical bug with string handling exposed on skeleton with many bones [1.43] - 2020-APR-25 Added: Static foot offset parameter to fix minor foot penetration Removed: Ground Plane Bone no longer used or needed (removed) Fixed: incorrect warning of missing counter lean bone when not using counter lean Added: mention of \"translucent mode\" to interactive rig docs Fixed: PowerIK now works in Standalone mode Fixed: Incorrect warnings about \"Missing effector bones called 'None'\" Fixed: Warnings, uninitialized GroundSlope variables Fixed: Procedural walking demo initializes foot locations correctly [1.42] - 2020-APR-23 Fixed: Crash when connecting PowerIK to layered blend per bone (and likely some other nodes too) [1.41] - 2020-APR-21 Added: Ground normal smoothed with max angular speed (degrees/sec) Added: Delta smoothing to grounded effectors Changed: Unreal, removed separate Ground struct on Effectors Fixed: Bug, FName to string conversion was using stack memory [1.4] - 2020-APR-20 Added: Ground alignment stride scaling Added: Ground alignment leaning (spine) and counter leaning (head) Added: Ground alignment adjustable foot rotation Changed: Ground alignment documentation includes all new features Added: SDK now fully documented online and commented in code Changed: SDK, all structs passed by const reference Changed: SDK, all settings broken out into structs with sensible default values Fixed: Solver bug causing PullWeight of zero to not be respected on hips. Fixed: General solver bug causing intermediate effectors to stretch skeleton [1.3] - 2020-APR-10 Added: Directional pull weight vectors. Added: \"NormalizePulling\" option on effectors for adding more power to body Added: \"PullBodyAmount\" to COG constraint to smooth out spine Added: \"RootRotationMultiplier\" to adjust amount of rotation on root Added: Ability to remove intermediate bones by setting Stiffness to 1.0 Added: Global multiplier on solver node to adjust effector smoothing Added: \"Prone\" biped ground align demo Added: 3-point VR tracker demo Changed: SDK SetEffectorTransform() split into 3 separate functions Changed: SDK no longer requires local transform in SetBones() Changed: UNREAL Ground settings in separate struct (shareable amongst effectors) Changed: UNREAL Smooth settings in separated struct (shareable amongst effectors) Added: UNREAL, bool toggle on PowerIKRig to disable component without having to remove it Added: Data for ground alignment control (new experimental feature) Fixed: SDK Bug causing elbows to flip in extreme poses Fixed: Unreal Bug causing names to get mangled in debug builds [1.22] - 2020-APR-04 Added: Optional, Pos/Rot temporal smoothing on effectors Added: Global solver alpha to blend everything on/off Added: \"RotateLimb\" bool on effector rotates whole limb smoothly Changed: \"IgnoreRotation\" now called \"RotateBone\" Changed: All solver data private / routed through API Changed: COG constraint now tunable Changed: changelog.txt and license.txt packaged in SDK Fixed: Crash if all PullWeights set to 0 Fixed: IsGrounded effectors now inherit ground angle [1.21] - 2020-MAR-30 Added: Support for 3-point VR tracking! (demo soon) Added: Stiffness constraint (experimental) Added: Center of Gravity constraint (needed for VR) Changed: much improved squash and stretch overall Fixed: Unreal project warnings [0.9] - 2020-MAR-26 Added: support for custom bending directions Added: plumbing to support joint limits (coming soon) Changed: improved fork joint rotation (smoother) Changed: effector PullWeights now behave much better Changed: Unreal Rig component effectors smaller and transparent Fixed: bug, crashed on skeletons with fork joints next to each other [0.8] - 2020-FEB-28 Fixed: packaging for Windows and Linux [0.7] - 2020-FEB-28 Added: Power IK Windows build available on Unreal Marketplace","title":"ChangeLog"},{"location":"sdk/change_log/#official-power-ik-change-log","text":"Added: new features. Changed: changes in existing functionality. Deprecated: soon-to-be removed features. Removed: now removed features. Fixed: any bug fixes.","title":"Official Power IK Change Log"},{"location":"sdk/change_log/#152-2020-aug-02","text":"Added: New Body Inertia setting in core solver (with Smooth and Spring modes) Added: Body Inertia settings to Ground Node, Walk Node, Solver Node and Control Rig node Added: Explicit control over final iteration count in solver (exposed on all nodes) Fixed: Ground Node double transform on body when using PullWeights and MoveRoot slope setting Changed: Walk Node, does not continuously update target plant location (avoids jitter stepping on uneven terrain) Changed: Ground Node, slope setting \"Push Feet Outer\" supports negative values Changed: Walk Node, stepping parameters exposed as pins Changed: Walk Node, removed clamp on walk parameters Changed: Walk Node, limb struct can be made with blueprint and all properties modified at runtime Changed: Walk Node, only prints teleport warning when \"PrintTeleportWarning\" is true for debugging","title":"[1.52] - 2020-AUG-02"},{"location":"sdk/change_log/#151-2020-jul-01","text":"Added: New Anim Graph node! \"Power IK Walk\" node creates procedural locomotion Added: New Core Solver upgrade efficiently produces more accurate and believable reaching Fixed: Bug in Core Solver; sub-root weights incorrect when Character Root was max distance from Effector Fixed: Bug in Core Solver; Bend Directions not respected when squash caused by sub-root rotation Changed: Ground Node's Delta Smooth Speed property exposed as a pin Removed: Power IK Rig Component (deprecated last release, use Control Rig now) Removed: PowerIK_Funcs blueprint function library (only needed for Rig component)","title":"[1.51] - 2020-JUL-01"},{"location":"sdk/change_log/#150-2020-jun-08","text":"Added: New Power IK Control Rig integration Added: New Power IK Ground Node, dedicated node for simpler ground setup Added: New Pole Vector support on Power IK Effectors Added: New PowerIK_UnrealCore.h system to make building your own nodes easier Added: New Debug drawing of ground raycast hit points and color coded rays Removed: \"IsGrounded\" bool from Power IK Effector (use Ground node now) Changed: Pos/Neg Pull Factor default on Ground node set to 0, 0, 1 Changed: All \"grounded\" examples now use Power IK Ground node Changed: \"JointLimits\" renamed \"BoneLimits\" for consistency Fixed: Massive refactor of SDK and Plugin code to support rapid development Fixed: Bug in core solver, effectors on inner forks did not squash limbs correctly Deprecated: The Power IK Interactive Rig component (use Control Rig now)","title":"[1.50] - 2020-JUN-08"},{"location":"sdk/change_log/#148-2020-may-31","text":"Added: SDK interface for adjusting skeleton before solve is run Added: SDK sample of procedural skeleton adjustment Added: SDK math functions MoveTowards, RotateTowards and PitchYawDecompose w/ comments Fixed: Bug, static foot offset did not follow foot normal Fixed: Bug, ground foot rotation was doubled up if RotateBone was off Changed: Default slope adjustment speed from 75 to 150 Changed: Ground alignment code removed from core solver Removed: IsGrounded flag from interactive rig component, didn't make sense & had bugs","title":"[1.48] - 2020-MAY-31"},{"location":"sdk/change_log/#147-2020-may-24","text":"Fixed: Bug in core solver, effectors not keeping bones 100% stable Changed: Code cleanup in SDK","title":"[1.47] - 2020-MAY-24"},{"location":"sdk/change_log/#146-2020-may-18","text":"Added: Support for Linux platform (multiplayer Linux servers) Added: Support for Unreal 4.25 Added: Separate position/rotation spaces on effectors Added: Changelog in docs Added: Docs better describe installation for Engine vs Project Fixed: SDK compiles warning free on clang and MSVC compilers Fixed: Packaging script removes potentially stale POWERIK.dll Added: Packaging script adds Changelog to docs Changed: Packaging script copies Changelog and License to top level folder Removed: (SDK) IsAdditive option on SetEffectorTransform(), assumes Component Space now","title":"[1.46] - 2020-MAY-18"},{"location":"sdk/change_log/#145-2020-may-02","text":"Added: \"Exclude Bones\" list on solver to remove bones from skeleton Fixed: packaging error when plugin installed in engine folder saying \"PrecompileForTargets\" Added: Error reporting in all SDK function return values Changed: SDK solver code modularized further","title":"[1.45] - 2020-MAY-02"},{"location":"sdk/change_log/#144-2020-may-01","text":"Fixed: plugin now works in precompiled mode (outside project) Fixed: compile errors in plugin when not using precompiled headers Fixed: critical bug with string handling exposed on skeleton with many bones","title":"[1.44] - 2020-MAY-01"},{"location":"sdk/change_log/#143-2020-apr-25","text":"Added: Static foot offset parameter to fix minor foot penetration Removed: Ground Plane Bone no longer used or needed (removed) Fixed: incorrect warning of missing counter lean bone when not using counter lean Added: mention of \"translucent mode\" to interactive rig docs Fixed: PowerIK now works in Standalone mode Fixed: Incorrect warnings about \"Missing effector bones called 'None'\" Fixed: Warnings, uninitialized GroundSlope variables Fixed: Procedural walking demo initializes foot locations correctly","title":"[1.43] - 2020-APR-25"},{"location":"sdk/change_log/#142-2020-apr-23","text":"Fixed: Crash when connecting PowerIK to layered blend per bone (and likely some other nodes too)","title":"[1.42] - 2020-APR-23"},{"location":"sdk/change_log/#141-2020-apr-21","text":"Added: Ground normal smoothed with max angular speed (degrees/sec) Added: Delta smoothing to grounded effectors Changed: Unreal, removed separate Ground struct on Effectors Fixed: Bug, FName to string conversion was using stack memory","title":"[1.41] - 2020-APR-21"},{"location":"sdk/change_log/#14-2020-apr-20","text":"Added: Ground alignment stride scaling Added: Ground alignment leaning (spine) and counter leaning (head) Added: Ground alignment adjustable foot rotation Changed: Ground alignment documentation includes all new features Added: SDK now fully documented online and commented in code Changed: SDK, all structs passed by const reference Changed: SDK, all settings broken out into structs with sensible default values Fixed: Solver bug causing PullWeight of zero to not be respected on hips. Fixed: General solver bug causing intermediate effectors to stretch skeleton","title":"[1.4] - 2020-APR-20"},{"location":"sdk/change_log/#13-2020-apr-10","text":"Added: Directional pull weight vectors. Added: \"NormalizePulling\" option on effectors for adding more power to body Added: \"PullBodyAmount\" to COG constraint to smooth out spine Added: \"RootRotationMultiplier\" to adjust amount of rotation on root Added: Ability to remove intermediate bones by setting Stiffness to 1.0 Added: Global multiplier on solver node to adjust effector smoothing Added: \"Prone\" biped ground align demo Added: 3-point VR tracker demo Changed: SDK SetEffectorTransform() split into 3 separate functions Changed: SDK no longer requires local transform in SetBones() Changed: UNREAL Ground settings in separate struct (shareable amongst effectors) Changed: UNREAL Smooth settings in separated struct (shareable amongst effectors) Added: UNREAL, bool toggle on PowerIKRig to disable component without having to remove it Added: Data for ground alignment control (new experimental feature) Fixed: SDK Bug causing elbows to flip in extreme poses Fixed: Unreal Bug causing names to get mangled in debug builds","title":"[1.3] - 2020-APR-10"},{"location":"sdk/change_log/#122-2020-apr-04","text":"Added: Optional, Pos/Rot temporal smoothing on effectors Added: Global solver alpha to blend everything on/off Added: \"RotateLimb\" bool on effector rotates whole limb smoothly Changed: \"IgnoreRotation\" now called \"RotateBone\" Changed: All solver data private / routed through API Changed: COG constraint now tunable Changed: changelog.txt and license.txt packaged in SDK Fixed: Crash if all PullWeights set to 0 Fixed: IsGrounded effectors now inherit ground angle","title":"[1.22] - 2020-APR-04"},{"location":"sdk/change_log/#121-2020-mar-30","text":"Added: Support for 3-point VR tracking! (demo soon) Added: Stiffness constraint (experimental) Added: Center of Gravity constraint (needed for VR) Changed: much improved squash and stretch overall Fixed: Unreal project warnings","title":"[1.21] - 2020-MAR-30"},{"location":"sdk/change_log/#09-2020-mar-26","text":"Added: support for custom bending directions Added: plumbing to support joint limits (coming soon) Changed: improved fork joint rotation (smoother) Changed: effector PullWeights now behave much better Changed: Unreal Rig component effectors smaller and transparent Fixed: bug, crashed on skeletons with fork joints next to each other","title":"[0.9] - 2020-MAR-26"},{"location":"sdk/change_log/#08-2020-feb-28","text":"Fixed: packaging for Windows and Linux","title":"[0.8] - 2020-FEB-28"},{"location":"sdk/change_log/#07-2020-feb-28","text":"Added: Power IK Windows build available on Unreal Marketplace","title":"[0.7] - 2020-FEB-28"},{"location":"sdk/convert_plugin/","text":"Convert Unreal Plugin to Source Code The Power IK Unreal plugin is provided using the binary version of the Power IK SDK. Source code licensees can use this guide to help them compile the plugin for different platforms. Preparation and Overview First make sure the binary plugin is installed into an Unreal project and is compiling and functioning correctly. Then follow these steps to replace the Power IK SDK binaries with the Source Code SDK which can be compiled for any platform. Step 1: Disable Binary Linking Open Plugins/PowerIK/Source/PowerIKSDK/PowerIKSDK.build.cs Set the boolean value POWERIK_BINARY_MODE = false; (default is true) This boolean gates the addition of the Power IK binary libraries to Unreal's build system. The Power IK .dll will no longer be copied into a packaged project folder. Step 2: Copy Source Code to Project Close Visual Studio Locate the PowerIK SDK source code you recieved when you purchased the SDK license. Copy/Replace the contents of PowerIK_SDK/include to: Plugins/PowerIK/Source/PowerIKSDK/include Copy/Replace the contents of PowerIK_SDK/src to: Plugins/PowerIK/Source/PowerIKSDK/src Right click on PROJECTNAME.uproject and Generate Visual Studio project files. Open the project solution in Visual Studio. You should see the PowerIK headers and source files in the Visual Studio Solution Explorer now. Step 3: Export Power IK Symbols for Linking By default, Power IK headers expect to import their symbols from a binary. You need to tell the compiler to export these symbols to the module .dll so they will be linked properly when packaging a project. Open Plugins/PowerIK/Source/PowerIKSDK/includes/PowerIK.h Locate #define POWERIK_EXPORTS at the top of the file and uncomment it Step 4: Build and Test Build the project in Visual Studio and launch the editor. Ensure that PowerIK is operating in the editor. Test packaging the project to ensure everything is working. If you encounter issues or missing instructions, please contact support@poweranimated.com (Optional) Whitelist New Platforms By default, the Power IK plugin is set to build for only Windows and Linux. You need to manually \"Whitelist\" new platforms to get the plugin to build for them. Open Plugins/PowerIK/PowerIK.uplugin Locate the \"Modules\" list at the bottom of this file. Add the new platform names to the \"WhitelistPlatforms\" list for all plugin modules. The Visual Studio project should now compile PowerIK from source for the platforms defined in the uplugin WhitelistPlatforms lists.","title":"Convert Unreal Plugin"},{"location":"sdk/convert_plugin/#convert-unreal-plugin-to-source-code","text":"The Power IK Unreal plugin is provided using the binary version of the Power IK SDK. Source code licensees can use this guide to help them compile the plugin for different platforms.","title":"Convert Unreal Plugin to Source Code"},{"location":"sdk/convert_plugin/#preparation-and-overview","text":"First make sure the binary plugin is installed into an Unreal project and is compiling and functioning correctly. Then follow these steps to replace the Power IK SDK binaries with the Source Code SDK which can be compiled for any platform.","title":"Preparation and Overview"},{"location":"sdk/convert_plugin/#step-1-disable-binary-linking","text":"Open Plugins/PowerIK/Source/PowerIKSDK/PowerIKSDK.build.cs Set the boolean value POWERIK_BINARY_MODE = false; (default is true) This boolean gates the addition of the Power IK binary libraries to Unreal's build system. The Power IK .dll will no longer be copied into a packaged project folder.","title":"Step 1: Disable Binary Linking"},{"location":"sdk/convert_plugin/#step-2-copy-source-code-to-project","text":"Close Visual Studio Locate the PowerIK SDK source code you recieved when you purchased the SDK license. Copy/Replace the contents of PowerIK_SDK/include to: Plugins/PowerIK/Source/PowerIKSDK/include Copy/Replace the contents of PowerIK_SDK/src to: Plugins/PowerIK/Source/PowerIKSDK/src Right click on PROJECTNAME.uproject and Generate Visual Studio project files. Open the project solution in Visual Studio. You should see the PowerIK headers and source files in the Visual Studio Solution Explorer now.","title":"Step 2: Copy Source Code to Project"},{"location":"sdk/convert_plugin/#step-3-export-power-ik-symbols-for-linking","text":"By default, Power IK headers expect to import their symbols from a binary. You need to tell the compiler to export these symbols to the module .dll so they will be linked properly when packaging a project. Open Plugins/PowerIK/Source/PowerIKSDK/includes/PowerIK.h Locate #define POWERIK_EXPORTS at the top of the file and uncomment it","title":"Step 3: Export Power IK Symbols for Linking"},{"location":"sdk/convert_plugin/#step-4-build-and-test","text":"Build the project in Visual Studio and launch the editor. Ensure that PowerIK is operating in the editor. Test packaging the project to ensure everything is working. If you encounter issues or missing instructions, please contact support@poweranimated.com","title":"Step 4: Build and Test"},{"location":"sdk/convert_plugin/#optional-whitelist-new-platforms","text":"By default, the Power IK plugin is set to build for only Windows and Linux. You need to manually \"Whitelist\" new platforms to get the plugin to build for them. Open Plugins/PowerIK/PowerIK.uplugin Locate the \"Modules\" list at the bottom of this file. Add the new platform names to the \"WhitelistPlatforms\" list for all plugin modules. The Visual Studio project should now compile PowerIK from source for the platforms defined in the uplugin WhitelistPlatforms lists.","title":"(Optional) Whitelist New Platforms"},{"location":"sdk/getting_started_sdk/","text":"Power IK C++ SDK The Power IK C++ SDK allows animation engineers to integrate Power IK into any animation software that can link C++ and uses skeletal animation. This includes, but is not limited to: game engines VR training software content creation software industrial simulations robotics Power IK is commercially licensed priorietary software. To enquire about licensing our SDK, please contact support@poweranimated.com. Unreal Integration Example The best example of how to integrate Power IK can be found right in the default Unreal Plugin. The sample FPowerIKCore class wraps the SDK and allows rapid integration of the solver into multiple Anim Graph nodes, and also into Unreal's Control Rig plugin. See PowerIK_UnrealCore.h for the FPowerIKCore class definition. Clients looking to integrate PowerIK into their own systems should reference this class to observe the necessary parts required to interface with the Power IK solver core. Using the Unreal Plugin With Source Code To compile and package the Power IK Unreal Plugin from source code, please follow the directions in the Convert Unreal Plugin section of these docs. You can ignore the rest of this document. Install the Source Code SDK Copy the entire SDK folder into a suitable location in the project directory. Add sdk/include to the project's headers Add sdk/src to the project's source Then include PowerIK.h into the project source file that will use PowerIK. Initialization PowerIK should be initialized in the following way: Instantiate a PowerIK::Solver() class. Call Solver.SetNumBones() to reserve space for the entire skeleton Call Solver.AddBone() for each bone in the skeleton Call Solver.SetRootBone() to specify the top bone (root of solver) Call Solver.AddEffector() for each effector (cannot add/remove effectors at runtime) On the first call to Solve(), PowerIK will allocate the necessary memory to support the bones and effectors that were added with AddBone(). There are no heap allocations after this. Update Overview Once PowerIK is initialized, it is ready to start Solving. At every tick in the simulation update loop: Give Power IK a new input pose. Update the effector settings (transforms, weights etc...). Call Solve() to generate a new pose. Copy the output pose out of the Solver and use it as desired NOTE: The input pose does not necessarily have to change from frame to frame. PowerIK will work equally well with static poses or animation (and both are useful in different scenarios). Update Details The update process should look like this: Call Solver.SetBoneTransform() for all bones to provide the input pose (the animation) Call Solver.SetEffectorTransform() for each effector to set their positions and rotations Call Solver.Solve() to run Power IK Call Solver.GetBoneTransform() to get the output pose See AnimNode_PowerIK::CopySolverInputs() and AnimNode_PowerIK::CopySolverOutputs() for examples of how to do these steps in Unreal. Note on Transform Spaces: All transforms (input/ouput on both bones and effectors) are considered to be in Character Space ( Component Space in Unreal nomenclature). This space usually has it's origin at the character's feet or root bone. PowerIK solves in this space, so it is most efficient to avoid conversion to/from local/bone space or world space and simply keep all bones and effectors in Character Space . Note on PowerIK Math Library: PowerIK uses it's own portable math library, so it is required to convert the positions and rotations to/from PowerIK::Vec3 and PowerIK::Quat format. These formats use plain 32-bit floats and should be convertable with any standard 3d-vector or quaternion format. Shutdown and Reset When the PowerIK::Solver() destructor is called, it releases all allocated memory. In cases where it is desirable to add/remove characters using PowerIK often, it may be better to keep a pool of solvers in memory and recycle them. To avoid reallocating memory, consider calling PowerIK::Solver().Reset(). This will clear the internal memory (without releasing it) to be re-used with a different skeleton or different set of effectors. Bones and Effectors must be re-added after calling Reset(). Treat a Reset() solver like a newly instantiated Solver(). If the new skeletons have more bones than before Reset(), additional allocations may occur. Once the Bones and Effectors are added, and Solve() has been called at least once, Power IK will never allocate more memory when calling Solve().","title":"Getting Started"},{"location":"sdk/getting_started_sdk/#power-ik-c-sdk","text":"The Power IK C++ SDK allows animation engineers to integrate Power IK into any animation software that can link C++ and uses skeletal animation. This includes, but is not limited to: game engines VR training software content creation software industrial simulations robotics Power IK is commercially licensed priorietary software. To enquire about licensing our SDK, please contact support@poweranimated.com.","title":"Power IK C++ SDK"},{"location":"sdk/getting_started_sdk/#unreal-integration-example","text":"The best example of how to integrate Power IK can be found right in the default Unreal Plugin. The sample FPowerIKCore class wraps the SDK and allows rapid integration of the solver into multiple Anim Graph nodes, and also into Unreal's Control Rig plugin. See PowerIK_UnrealCore.h for the FPowerIKCore class definition. Clients looking to integrate PowerIK into their own systems should reference this class to observe the necessary parts required to interface with the Power IK solver core.","title":"Unreal Integration Example"},{"location":"sdk/getting_started_sdk/#using-the-unreal-plugin-with-source-code","text":"To compile and package the Power IK Unreal Plugin from source code, please follow the directions in the Convert Unreal Plugin section of these docs. You can ignore the rest of this document.","title":"Using the Unreal Plugin With Source Code"},{"location":"sdk/getting_started_sdk/#install-the-source-code-sdk","text":"Copy the entire SDK folder into a suitable location in the project directory. Add sdk/include to the project's headers Add sdk/src to the project's source Then include PowerIK.h into the project source file that will use PowerIK.","title":"Install the Source Code SDK"},{"location":"sdk/getting_started_sdk/#initialization","text":"PowerIK should be initialized in the following way: Instantiate a PowerIK::Solver() class. Call Solver.SetNumBones() to reserve space for the entire skeleton Call Solver.AddBone() for each bone in the skeleton Call Solver.SetRootBone() to specify the top bone (root of solver) Call Solver.AddEffector() for each effector (cannot add/remove effectors at runtime) On the first call to Solve(), PowerIK will allocate the necessary memory to support the bones and effectors that were added with AddBone(). There are no heap allocations after this.","title":"Initialization"},{"location":"sdk/getting_started_sdk/#update-overview","text":"Once PowerIK is initialized, it is ready to start Solving. At every tick in the simulation update loop: Give Power IK a new input pose. Update the effector settings (transforms, weights etc...). Call Solve() to generate a new pose. Copy the output pose out of the Solver and use it as desired NOTE: The input pose does not necessarily have to change from frame to frame. PowerIK will work equally well with static poses or animation (and both are useful in different scenarios).","title":"Update Overview"},{"location":"sdk/getting_started_sdk/#update-details","text":"The update process should look like this: Call Solver.SetBoneTransform() for all bones to provide the input pose (the animation) Call Solver.SetEffectorTransform() for each effector to set their positions and rotations Call Solver.Solve() to run Power IK Call Solver.GetBoneTransform() to get the output pose See AnimNode_PowerIK::CopySolverInputs() and AnimNode_PowerIK::CopySolverOutputs() for examples of how to do these steps in Unreal. Note on Transform Spaces: All transforms (input/ouput on both bones and effectors) are considered to be in Character Space ( Component Space in Unreal nomenclature). This space usually has it's origin at the character's feet or root bone. PowerIK solves in this space, so it is most efficient to avoid conversion to/from local/bone space or world space and simply keep all bones and effectors in Character Space . Note on PowerIK Math Library: PowerIK uses it's own portable math library, so it is required to convert the positions and rotations to/from PowerIK::Vec3 and PowerIK::Quat format. These formats use plain 32-bit floats and should be convertable with any standard 3d-vector or quaternion format.","title":"Update Details"},{"location":"sdk/getting_started_sdk/#shutdown-and-reset","text":"When the PowerIK::Solver() destructor is called, it releases all allocated memory. In cases where it is desirable to add/remove characters using PowerIK often, it may be better to keep a pool of solvers in memory and recycle them. To avoid reallocating memory, consider calling PowerIK::Solver().Reset(). This will clear the internal memory (without releasing it) to be re-used with a different skeleton or different set of effectors. Bones and Effectors must be re-added after calling Reset(). Treat a Reset() solver like a newly instantiated Solver(). If the new skeletons have more bones than before Reset(), additional allocations may occur. Once the Bones and Effectors are added, and Solve() has been called at least once, Power IK will never allocate more memory when calling Solve().","title":"Shutdown and Reset"},{"location":"sdk/settings_cog/","text":"PowerIK::CenterOfGravitySettings Struct struct POWERIK_LIB_API CenterOfGravitySettings The settings used to control the center of gravity constraint. float Alpha Amount to apply center of gravity constraint. Range is 0-1. Default is 0. float HorizAmount Amount to counteract root position in horizontal plane (relative to gravity). Range is 0-inf. Default is 1.2. float VertAmount Amount to counteract root position vertically (opposite to gravity). Range is 0-inf. Default is 0.3. float PullBodyAmount Amount to pull the rest of the body connected to the root. Range is 0-inf. Default is 0.4.","title":"Center of Gravity Settings"},{"location":"sdk/settings_cog/#powerikcenterofgravitysettings-struct","text":"","title":"PowerIK::CenterOfGravitySettings Struct"},{"location":"sdk/settings_cog/#struct-powerik_lib_api-centerofgravitysettings","text":"The settings used to control the center of gravity constraint.","title":"struct POWERIK_LIB_API CenterOfGravitySettings"},{"location":"sdk/settings_cog/#float-alpha","text":"Amount to apply center of gravity constraint. Range is 0-1. Default is 0.","title":"float Alpha"},{"location":"sdk/settings_cog/#float-horizamount","text":"Amount to counteract root position in horizontal plane (relative to gravity). Range is 0-inf. Default is 1.2.","title":"float HorizAmount"},{"location":"sdk/settings_cog/#float-vertamount","text":"Amount to counteract root position vertically (opposite to gravity). Range is 0-inf. Default is 0.3.","title":"float VertAmount"},{"location":"sdk/settings_cog/#float-pullbodyamount","text":"Amount to pull the rest of the body connected to the root. Range is 0-inf. Default is 0.4.","title":"float PullBodyAmount"},{"location":"sdk/settings_ground/","text":"PowerIK::GroundSettings Struct struct POWERIK_LIB_API GroundSettings The settings used control ground alignment. These settings have no effect unless at least 1 effector has IsGrounded on. Vec3 Normal Vector that is normal to the ground surface. Default is +Z. Vec3 StrideDirection Normalized vector that describes the direction of travel. float MaxGroundAngle Maximum angle relative to gravity vector to apply leaning and stride scaling. bool ScaleStride If true, stride of IsGrounded effectors will be scaled in Stride Direction. float UphillStrideScale Amount to scale stride when going uphill. Range is 0-1. Default 0.4. float DownhillStrideScale Amount to scale stride when going downhill. Range is 0-1. Default 0.2. float SidehillStrideScale Amount to scale stride when on a side-hill. Range is 0-1. Default 1.0. float SidehillPushOuterFeet Amount (in centimeters) to push outside feet outwards on sidehills. Default is 20.0. float SidehillPushInnerFeet Amount (in centimeters) to push inside feet outwards on sidehills. Default is 10.0. bool Lean If True, character root bone is rotated in opposite direction of ground normal. float UphillLean Amount to lean forward when going uphill. Range is 0-1. Default 0.3. float DownhillLean Amount to lean backward when going downhill. Range is 0-1. Default 0.5. float SidehillLean Amount to lean sideways into side-hills. Range is 0-1. Default 0.0. bool CounterLean If True, will counter lean CounterLeanBone. Usually this is the head. const char* CounterLeanBoneName Name of base of counter lean bone. Usually this is the base Head bone. float UphillCounterLean Amount to counter lean backward when going uphill. Range is 0-1. Default 0.8. float DownhillCounterLean Amount to counter lean backward when going downhill. Range is 0-1. Default 1.0. float SidehillCounterLean Amount to counter lean sideways into side-hills. Range is 0-1. Default 0.0. bool MoveRoot If True, character root bone position is gradually pushed vertically and horizontally. float UphillVertOffset Amount (in centimeters) to push the character root up/down when going UP hill. Default 10.0. float UphillHorizOffset Amount (in centimeters) to push the character root forward/back when going UP hill. Default -20.0. float DownhillVertOffset Amount (in centimeters) to push the character root up/down when going DOWN hill. Default 10.0. float DownhillHorizOffset Amount (in centimeters) to push the character root forward/back when going DOWN hill. Default 20.0. float SidehillVertOffset Amount (in centimeters) to push the character root up/down when on a SIDE hill. Default -10.0. float SidehillHorizOffset Amount (in centimeters) to push the character root forward/back when on a SIDE hill. Default -10.0. bool RotateFootToGround If True, feet are oriented to ground normal. float PitchFootAmount Amount to pitch foot to orient to up/down hills. Range is 0-1. Default 1.0. float RollFootAmount Amount to roll foot to orient to sidehills. Range is 0-1. Default 0.6.","title":"Ground Settings"},{"location":"sdk/settings_ground/#powerikgroundsettings-struct","text":"","title":"PowerIK::GroundSettings Struct"},{"location":"sdk/settings_ground/#struct-powerik_lib_api-groundsettings","text":"The settings used control ground alignment. These settings have no effect unless at least 1 effector has IsGrounded on.","title":"struct POWERIK_LIB_API GroundSettings"},{"location":"sdk/settings_ground/#vec3-normal","text":"Vector that is normal to the ground surface. Default is +Z.","title":"Vec3 Normal"},{"location":"sdk/settings_ground/#vec3-stridedirection","text":"Normalized vector that describes the direction of travel.","title":"Vec3 StrideDirection"},{"location":"sdk/settings_ground/#float-maxgroundangle","text":"Maximum angle relative to gravity vector to apply leaning and stride scaling.","title":"float MaxGroundAngle"},{"location":"sdk/settings_ground/#bool-scalestride","text":"If true, stride of IsGrounded effectors will be scaled in Stride Direction.","title":"bool ScaleStride"},{"location":"sdk/settings_ground/#float-uphillstridescale","text":"Amount to scale stride when going uphill. Range is 0-1. Default 0.4.","title":"float UphillStrideScale"},{"location":"sdk/settings_ground/#float-downhillstridescale","text":"Amount to scale stride when going downhill. Range is 0-1. Default 0.2.","title":"float DownhillStrideScale"},{"location":"sdk/settings_ground/#float-sidehillstridescale","text":"Amount to scale stride when on a side-hill. Range is 0-1. Default 1.0.","title":"float SidehillStrideScale"},{"location":"sdk/settings_ground/#float-sidehillpushouterfeet","text":"Amount (in centimeters) to push outside feet outwards on sidehills. Default is 20.0.","title":"float SidehillPushOuterFeet"},{"location":"sdk/settings_ground/#float-sidehillpushinnerfeet","text":"Amount (in centimeters) to push inside feet outwards on sidehills. Default is 10.0.","title":"float SidehillPushInnerFeet"},{"location":"sdk/settings_ground/#bool-lean","text":"If True, character root bone is rotated in opposite direction of ground normal.","title":"bool Lean"},{"location":"sdk/settings_ground/#float-uphilllean","text":"Amount to lean forward when going uphill. Range is 0-1. Default 0.3.","title":"float UphillLean"},{"location":"sdk/settings_ground/#float-downhilllean","text":"Amount to lean backward when going downhill. Range is 0-1. Default 0.5.","title":"float DownhillLean"},{"location":"sdk/settings_ground/#float-sidehilllean","text":"Amount to lean sideways into side-hills. Range is 0-1. Default 0.0.","title":"float SidehillLean"},{"location":"sdk/settings_ground/#bool-counterlean","text":"If True, will counter lean CounterLeanBone. Usually this is the head.","title":"bool CounterLean"},{"location":"sdk/settings_ground/#const-char-counterleanbonename","text":"Name of base of counter lean bone. Usually this is the base Head bone.","title":"const char* CounterLeanBoneName"},{"location":"sdk/settings_ground/#float-uphillcounterlean","text":"Amount to counter lean backward when going uphill. Range is 0-1. Default 0.8.","title":"float UphillCounterLean"},{"location":"sdk/settings_ground/#float-downhillcounterlean","text":"Amount to counter lean backward when going downhill. Range is 0-1. Default 1.0.","title":"float DownhillCounterLean"},{"location":"sdk/settings_ground/#float-sidehillcounterlean","text":"Amount to counter lean sideways into side-hills. Range is 0-1. Default 0.0.","title":"float SidehillCounterLean"},{"location":"sdk/settings_ground/#bool-moveroot","text":"If True, character root bone position is gradually pushed vertically and horizontally.","title":"bool MoveRoot"},{"location":"sdk/settings_ground/#float-uphillvertoffset","text":"Amount (in centimeters) to push the character root up/down when going UP hill. Default 10.0.","title":"float UphillVertOffset"},{"location":"sdk/settings_ground/#float-uphillhorizoffset","text":"Amount (in centimeters) to push the character root forward/back when going UP hill. Default -20.0.","title":"float UphillHorizOffset"},{"location":"sdk/settings_ground/#float-downhillvertoffset","text":"Amount (in centimeters) to push the character root up/down when going DOWN hill. Default 10.0.","title":"float DownhillVertOffset"},{"location":"sdk/settings_ground/#float-downhillhorizoffset","text":"Amount (in centimeters) to push the character root forward/back when going DOWN hill. Default 20.0.","title":"float DownhillHorizOffset"},{"location":"sdk/settings_ground/#float-sidehillvertoffset","text":"Amount (in centimeters) to push the character root up/down when on a SIDE hill. Default -10.0.","title":"float SidehillVertOffset"},{"location":"sdk/settings_ground/#float-sidehillhorizoffset","text":"Amount (in centimeters) to push the character root forward/back when on a SIDE hill. Default -10.0.","title":"float SidehillHorizOffset"},{"location":"sdk/settings_ground/#bool-rotatefoottoground","text":"If True, feet are oriented to ground normal.","title":"bool RotateFootToGround"},{"location":"sdk/settings_ground/#float-pitchfootamount","text":"Amount to pitch foot to orient to up/down hills. Range is 0-1. Default 1.0.","title":"float PitchFootAmount"},{"location":"sdk/settings_ground/#float-rollfootamount","text":"Amount to roll foot to orient to sidehills. Range is 0-1. Default 0.6.","title":"float RollFootAmount"},{"location":"sdk/settings_smoothing/","text":"PowerIK::EffectorSmoothingSettings Struct struct POWERIK_LIB_API EffectorSmoothingSettings The settings used control the position and rotation smoothing of effectors. bool SmoothPositionOverTime If true, the position of the effector will be smoothed over time. float MaxPositionSpeed Maximum speed an effector can move in centimeters per second. float MaxPositionDistance Maximum distance an effector can be from it's input position in centimeters. bool SmoothRotationOverTime If true, the rotation of the effector will be smoothed over time. float MaxDegreesSpeed Maximum speed an effector can rotate in degrees per second. float MaxDegreesDistance Maximum distance an effector angle can be from it's input rotation in degrees.","title":"Effector Smoothing Settings"},{"location":"sdk/settings_smoothing/#powerikeffectorsmoothingsettings-struct","text":"","title":"PowerIK::EffectorSmoothingSettings Struct"},{"location":"sdk/settings_smoothing/#struct-powerik_lib_api-effectorsmoothingsettings","text":"The settings used control the position and rotation smoothing of effectors.","title":"struct POWERIK_LIB_API EffectorSmoothingSettings"},{"location":"sdk/settings_smoothing/#bool-smoothpositionovertime","text":"If true, the position of the effector will be smoothed over time.","title":"bool SmoothPositionOverTime"},{"location":"sdk/settings_smoothing/#float-maxpositionspeed","text":"Maximum speed an effector can move in centimeters per second.","title":"float MaxPositionSpeed"},{"location":"sdk/settings_smoothing/#float-maxpositiondistance","text":"Maximum distance an effector can be from it's input position in centimeters.","title":"float MaxPositionDistance"},{"location":"sdk/settings_smoothing/#bool-smoothrotationovertime","text":"If true, the rotation of the effector will be smoothed over time.","title":"bool SmoothRotationOverTime"},{"location":"sdk/settings_smoothing/#float-maxdegreesspeed","text":"Maximum speed an effector can rotate in degrees per second.","title":"float MaxDegreesSpeed"},{"location":"sdk/settings_smoothing/#float-maxdegreesdistance","text":"Maximum distance an effector angle can be from it's input rotation in degrees.","title":"float MaxDegreesDistance"},{"location":"sdk/settings_solver/","text":"PowerIK::SolverSettings Struct struct POWERIK_LIB_API SolverSettings The settings used for the core solver. These setting only have to be set once. Though they can all be changed at runtime if desired. unsigned int SquashIterations Number of iterations to determine squashed limb shape. Default is 6. unsigned int StretchIterations Number of iterations to determine stretched limb shape. Default is 6. Vec3 WorldUpNormal Up direction of world. Used for Center of Gravity and Grounding. Default is +Z (Unreal). float RootRotationMultiplier Amount to rotate the root in response to effectors. Default is 1.0. Value as high as 3 or 4 may be necessary in some cases.","title":"Solver Settings"},{"location":"sdk/settings_solver/#poweriksolversettings-struct","text":"","title":"PowerIK::SolverSettings Struct"},{"location":"sdk/settings_solver/#struct-powerik_lib_api-solversettings","text":"The settings used for the core solver. These setting only have to be set once. Though they can all be changed at runtime if desired.","title":"struct POWERIK_LIB_API SolverSettings"},{"location":"sdk/settings_solver/#unsigned-int-squashiterations","text":"Number of iterations to determine squashed limb shape. Default is 6.","title":"unsigned int SquashIterations"},{"location":"sdk/settings_solver/#unsigned-int-stretchiterations","text":"Number of iterations to determine stretched limb shape. Default is 6.","title":"unsigned int StretchIterations"},{"location":"sdk/settings_solver/#vec3-worldupnormal","text":"Up direction of world. Used for Center of Gravity and Grounding. Default is +Z (Unreal).","title":"Vec3 WorldUpNormal"},{"location":"sdk/settings_solver/#float-rootrotationmultiplier","text":"Amount to rotate the root in response to effectors. Default is 1.0. Value as high as 3 or 4 may be necessary in some cases.","title":"float RootRotationMultiplier"},{"location":"sdk/solver/","text":"PowerIK::Solver Class Documentation Solver() Creates a new instance of a PowerIK solver. Do this once per animated skeleton. void Solve(const float DeltaTime, const float Alpha) const Call this every tick to generate a new pose based on the input pose and the effectors. Parameters: DeltaTime \u2014 - the time (in seconds since the last call to Solve(). PowerIK is deterministic, this is only needed for effector smoothing. Alpha \u2014 - blend the entire effect of the solver off and on (0-1). At 0, the solve is skipped entirely and the input pose is completely unchanged. void Reset() const Call this to reset all internal data structures. Will not deallocate. Useful for recycling solver memory. void SetNumBones(int NumBones) const Call this on a new Solver() or only AFTER calling Reset() to expand/allocate space for a new skeleton. int GetNumBones() const Returns: - int, number of bones in the solver PowerIKErrorCode AddBone( const int BoneIndex, const char* BoneName, const int ParentIndex) const Call this for each bone AFTER calling SetNumBones(). Supplies hierarchy information to solver. Parameters: BoneIndex \u2014 - the index of the bone. Index must be >= 0 and less than NumBones. BoneName \u2014 - the string name of the Bone. This name must match the name passed to AddEffector() ParentIndex \u2014 - the index of the bone this bone is parented to or -1 for the root (no parent). Returns: - SUCCESS or OUT_OF_BOUNDS if either BoneIndex or ParentIndex are invalid PowerIKErrorCode AddEffector( const char* BoneName, int& OutEffectorIndex) const Call this AFTER called AddBone() for the whole skeleton. Adds an effector to a given bone (by name). Parameters: BoneName \u2014 - the string name of the Bone to affect. This name must match the name passed to AddBone(). OutEffectorIndex \u2014 - the index of the newly created effector. Store this and use it in SetEffectorTransform() Returns: - SUCCESS or FAILURE if BoneName is invalid int GetNumEffectors() const Get how many effectors have been added to the solver. Returns: - int, number of effectors in the solver const char* GetEffectorName(const unsigned int EffectorIndex) Get name of the bone associated with the given effector. Returns: - a pointer to array of char holding the name of the bone for the effector. Returns empty string if index is out of range. PowerIKErrorCode SetRootBone(const int BoneIndex) const Tell the solver what the root bone is. All bones ABOVE the root are culled from the solver entirely. Parameters: BoneIndex \u2014 - all of the ground settings Returns: - SUCCESS or OUT_OF_BOUNDS if BoneIndex is invalid const char* GetRootBoneName() const Get name of the currently set root bone. Returns: - a pointer to array of char holding the name of the root bone. Returns empty string if no root has been set. void SetSolverSettings(const SolverSettings& Settings) const Optional method to modify internal solver settings like iteration counts. Parameters: Settings \u2014 - all the solver settings void SetCOGSettings(const CenterOfGravitySettings& Settings) const Optional method to setup Center of Gravity constraint on root bone. Parameters: Settings \u2014 - all of the center of gravity settings void SetBoneTransform( const int BoneIndex, const Vec3& Position, const Quat& Rotation) const Call this every tick, for each bone, before Solve() to update the input pose. Parameters: BoneIndex \u2014 - the index of the bone. Index must be >= 0 and less than NumBones. Position \u2014 - the Character Space 3d position of the bone Rotation \u2014 - the Character Space rotation of the bone as a quaternion void GetBoneTransform( const int BoneIndex, Vec3& OutPosition, Quat& OutRotation) const Call this every tick, for each bone, AFTER Solve() to get the generated output pose. Parameters: BoneIndex \u2014 - the index of the bone. Index must be >= 0 and less than NumBones. OutPosition \u2014 - the Character Space 3d position of the bone OutRotation \u2014 - the Character Space rotation of the bone as a quaternion PowerIKErrorCode SetEffectorTransform( const int EffectorIndex, const Vec3& Position, const Quat& Rotation, const bool RotateBone, const bool RotateLimb) const Optionally call this every tick, for each effector, before Solve() to update the effector transform settings. Parameters: EffectorIndex \u2014 - the index of the effector (as returned from AddEffector) Position \u2014 - the Character Space 3d position of the effector Rotation \u2014 - the Character Space rotation of the effector as a quaternion RotateBone \u2014 - if True, affected Bone will rotate to match effector rotation RotateLimb \u2014 - if True, Bones near this effector will be rotated with the effector Returns: - SUCCESS or OUT_OF_BOUNDS if EffectorIndex is invalid PowerIKErrorCode SetEffectorWeights( const int EffectorIndex, const float Alpha, const float PullWeight, const bool NormalizePulling, const Vec3& PositivePullFactor, const Vec3& NegativePullFactor) const Optionally call this every tick, for each effector, before Solve() to update the effector weight settings. Parameters: EffectorIndex \u2014 - the index of the effector (as returned from AddEffector) Alpha \u2014 - used to blend the effect of the effector on/off. Ranges from 0 to 1. PullWeight \u2014 - determines the degree of effect this effector has on the rest of the body. Normalized relative to all other PullWeight values. NormalizePulling \u2014 - if True, total PullWeight on body is normalized to 1 to avoid over/under shooting. PositivePullFactor \u2014 - multiplies effect of this effector on the rest of the body in the positive directions NegativePullFactor \u2014 - multiplies effect of this effector on the rest of the body in the negative directions Returns: - SUCCESS or OUT_OF_BOUNDS if EffectorIndex is invalid PowerIKErrorCode SetEffectorSettings( const int EffectorIndex, const float DeltaSmoothSpeed, const bool AffectsCenterOfGravity) const Optionally call this every tick, for each effector, before Solve() to update the effector weight settings. Parameters: EffectorIndex \u2014 - the index of the effector (as returned from AddEffector) DeltaSmoothSpeed \u2014 - speed in centimeters per second that this effector adjusts to changing ground height. AffectsCenterOfGravity \u2014 - multiplies effect of this effector on the rest of the body in the negative directions Returns: - SUCCESS or OUT_OF_BOUNDS if EffectorIndex is invalid PowerIKErrorCode SetEffectorSmoothing( const int EffectorIndex, const EffectorSmoothingSettings& Settings) const Optionally call this to smooth an effector's position and/or rotation over time Parameters: EffectorIndex \u2014 - the index of the effector (as returned from AddEffector) Settings \u2014 - the position and rotation smoothing settings Returns: - SUCCESS or OUT_OF_BOUNDS if EffectorIndex is invalid PowerIKErrorCode SetEffectorPoleVector( const int EffectorIndex, const EffectorPoleVector& PoleVector) const Optionally call this to specify an Effector's pole vector settings Parameters: EffectorIndex \u2014 - the index of the effector (as returned from AddEffector) PoleVector \u2014 - the settings defining the Pole Vector behavior Returns: - SUCCESS or OUT_OF_BOUNDS if EffectorIndex is invalid PowerIKErrorCode SetBoneBendDirection( const int BoneIndex, const Vec3& Direction) const Optionally call this to specify a custom bending direction for a single bone Parameters: BoneIndex \u2014 - the index of the bone (as passed to AddBone) Direction \u2014 - a 3d vector in the local space of the bone that is the direction the bone will move in when bending Returns: - SUCCESS or OUT_OF_BOUNDS if BoneIndex is invalid PowerIKErrorCode SetBoneLimits( const int BoneIndex, const float Stiffness, const bool UseLimits, const Vec3& MinAngles, const Vec3& MaxAngles, const bool NegateXAxis) const EXPERIMENTAL! Optionally call this to specify a set of limits and stiffness for a bone Parameters: BoneIndex \u2014 - the index of the bone (as passed to AddBone) Stiffness \u2014 - ranges from 0 to 1. Default is 0. At 1 the bone is completely rigid and will be removed from the solve entirely. UseLimits \u2014 - turn limits on/off. MinAngles \u2014 - minimum allowable X, Y and Z rotations relative to parent MaxAngles \u2014 - maximum allowable X, Y and Z rotations relative to parent NegateXAxis \u2014 - consider limits in opposite direction along X-axis Returns: - SUCCESS or OUT_OF_BOUNDS if BoneIndex is invalid PowerIKErrorCode GetBoneLimits( const int BoneIndex, Vec3& OutMinLimits, Vec3& OutMaxLimits, bool& OutNegateXAxis, bool& HasLimits) const Optionally call this to get the limits for a bone. If the bone has no limits Parameters: BoneIndex \u2014 - the index of the bone OutMinLimits \u2014 - minimum allowable X, Y and Z rotations relative to parent OutMaxLimits \u2014 - maximum allowable X, Y and Z rotations relative to parent OutNegateXAxis \u2014 - consider limits in opposite direction along X-axis HasLimits \u2014 - True if the bone has limits, false otherwise (all Out values will be untouched) Returns: - SUCCESS or OUT_OF_BOUNDS if BoneIndex is invalid PowerIKErrorCode ExcludeBone(const int BoneIndex) const Exclude the given bone. It will be treated as 100% stiff and the solver will ignore it. Parameters: BoneIndex \u2014 - the index of the bone (as passed to AddBone) Returns: - SUCCESS or OUT_OF_BOUNDS if BoneIndex is invalid void TranslateSkeletonBeforeSolve(const Vec3& PositionOffset) const Convenience method for providing global offsets to the skeleton to be applied internally before the main solver pass. Parameters: PositionOffset \u2014 - the amount to translate the entire skeleton void RotateSkeletonBeforeSolve(const Quat& RotationOffset) const Convenience method for providing global offsets to the skeleton to be applied internally before the main solver pass. Parameters: RotationOffset \u2014 - the amount to rotate the entire skeleton PowerIKErrorCode RotateBoneBeforeSolve( const Quat& RotationOffset, const int BoneIndex) const Convenience method for providing local rotate offsets to specific bones to be applied internally before the main solver pass. Parameters: RotationOffset \u2014 - character space rotation offset applied relative to input pose BoneIndex \u2014 - the index of the bone (as passed to AddBone) Returns: - SUCCESS or OUT_OF_BOUNDS if BoneIndex is invalid","title":"Solver Class"},{"location":"sdk/solver/#poweriksolver-class","text":"","title":"PowerIK::Solver Class"},{"location":"sdk/solver/#documentation","text":"","title":"Documentation"},{"location":"sdk/solver/#solver","text":"Creates a new instance of a PowerIK solver. Do this once per animated skeleton.","title":"Solver()"},{"location":"sdk/solver/#void-solveconst-float-deltatime-const-float-alpha-const","text":"Call this every tick to generate a new pose based on the input pose and the effectors. Parameters: DeltaTime \u2014 - the time (in seconds since the last call to Solve(). PowerIK is deterministic, this is only needed for effector smoothing. Alpha \u2014 - blend the entire effect of the solver off and on (0-1). At 0, the solve is skipped entirely and the input pose is completely unchanged.","title":"void Solve(const float DeltaTime, const float Alpha) const"},{"location":"sdk/solver/#void-reset-const","text":"Call this to reset all internal data structures. Will not deallocate. Useful for recycling solver memory.","title":"void Reset() const"},{"location":"sdk/solver/#void-setnumbonesint-numbones-const","text":"Call this on a new Solver() or only AFTER calling Reset() to expand/allocate space for a new skeleton.","title":"void SetNumBones(int NumBones) const"},{"location":"sdk/solver/#int-getnumbones-const","text":"Returns: - int, number of bones in the solver","title":"int GetNumBones() const"},{"location":"sdk/solver/#powerikerrorcode-addbone-const-int-boneindex-const-char-bonename-const-int-parentindex-const","text":"Call this for each bone AFTER calling SetNumBones(). Supplies hierarchy information to solver. Parameters: BoneIndex \u2014 - the index of the bone. Index must be >= 0 and less than NumBones. BoneName \u2014 - the string name of the Bone. This name must match the name passed to AddEffector() ParentIndex \u2014 - the index of the bone this bone is parented to or -1 for the root (no parent). Returns: - SUCCESS or OUT_OF_BOUNDS if either BoneIndex or ParentIndex are invalid","title":"PowerIKErrorCode AddBone(   const int BoneIndex,   const char* BoneName,   const int ParentIndex) const"},{"location":"sdk/solver/#powerikerrorcode-addeffector-const-char-bonename-int-outeffectorindex-const","text":"Call this AFTER called AddBone() for the whole skeleton. Adds an effector to a given bone (by name). Parameters: BoneName \u2014 - the string name of the Bone to affect. This name must match the name passed to AddBone(). OutEffectorIndex \u2014 - the index of the newly created effector. Store this and use it in SetEffectorTransform() Returns: - SUCCESS or FAILURE if BoneName is invalid","title":"PowerIKErrorCode AddEffector(   const char* BoneName,   int&amp; OutEffectorIndex) const"},{"location":"sdk/solver/#int-getnumeffectors-const","text":"Get how many effectors have been added to the solver. Returns: - int, number of effectors in the solver","title":"int GetNumEffectors() const"},{"location":"sdk/solver/#const-char-geteffectornameconst-unsigned-int-effectorindex","text":"Get name of the bone associated with the given effector. Returns: - a pointer to array of char holding the name of the bone for the effector. Returns empty string if index is out of range.","title":"const char* GetEffectorName(const unsigned int EffectorIndex)"},{"location":"sdk/solver/#powerikerrorcode-setrootboneconst-int-boneindex-const","text":"Tell the solver what the root bone is. All bones ABOVE the root are culled from the solver entirely. Parameters: BoneIndex \u2014 - all of the ground settings Returns: - SUCCESS or OUT_OF_BOUNDS if BoneIndex is invalid","title":"PowerIKErrorCode SetRootBone(const int BoneIndex) const"},{"location":"sdk/solver/#const-char-getrootbonename-const","text":"Get name of the currently set root bone. Returns: - a pointer to array of char holding the name of the root bone. Returns empty string if no root has been set.","title":"const char* GetRootBoneName() const"},{"location":"sdk/solver/#void-setsolversettingsconst-solversettings-settings-const","text":"Optional method to modify internal solver settings like iteration counts. Parameters: Settings \u2014 - all the solver settings","title":"void SetSolverSettings(const SolverSettings&amp; Settings) const"},{"location":"sdk/solver/#void-setcogsettingsconst-centerofgravitysettings-settings-const","text":"Optional method to setup Center of Gravity constraint on root bone. Parameters: Settings \u2014 - all of the center of gravity settings","title":"void SetCOGSettings(const CenterOfGravitySettings&amp; Settings) const"},{"location":"sdk/solver/#void-setbonetransform-const-int-boneindex-const-vec3-position-const-quat-rotation-const","text":"Call this every tick, for each bone, before Solve() to update the input pose. Parameters: BoneIndex \u2014 - the index of the bone. Index must be >= 0 and less than NumBones. Position \u2014 - the Character Space 3d position of the bone Rotation \u2014 - the Character Space rotation of the bone as a quaternion","title":"void SetBoneTransform(   const int BoneIndex,   const Vec3&amp; Position,   const Quat&amp; Rotation) const"},{"location":"sdk/solver/#void-getbonetransform-const-int-boneindex-vec3-outposition-quat-outrotation-const","text":"Call this every tick, for each bone, AFTER Solve() to get the generated output pose. Parameters: BoneIndex \u2014 - the index of the bone. Index must be >= 0 and less than NumBones. OutPosition \u2014 - the Character Space 3d position of the bone OutRotation \u2014 - the Character Space rotation of the bone as a quaternion","title":"void GetBoneTransform(   const int BoneIndex,   Vec3&amp; OutPosition,   Quat&amp; OutRotation) const"},{"location":"sdk/solver/#powerikerrorcode-seteffectortransform-const-int-effectorindex-const-vec3-position-const-quat-rotation-const-bool-rotatebone-const-bool-rotatelimb-const","text":"Optionally call this every tick, for each effector, before Solve() to update the effector transform settings. Parameters: EffectorIndex \u2014 - the index of the effector (as returned from AddEffector) Position \u2014 - the Character Space 3d position of the effector Rotation \u2014 - the Character Space rotation of the effector as a quaternion RotateBone \u2014 - if True, affected Bone will rotate to match effector rotation RotateLimb \u2014 - if True, Bones near this effector will be rotated with the effector Returns: - SUCCESS or OUT_OF_BOUNDS if EffectorIndex is invalid","title":"PowerIKErrorCode SetEffectorTransform(   const int EffectorIndex,   const Vec3&amp; Position,   const Quat&amp; Rotation,   const bool RotateBone,   const bool RotateLimb) const"},{"location":"sdk/solver/#powerikerrorcode-seteffectorweights-const-int-effectorindex-const-float-alpha-const-float-pullweight-const-bool-normalizepulling-const-vec3-positivepullfactor-const-vec3-negativepullfactor-const","text":"Optionally call this every tick, for each effector, before Solve() to update the effector weight settings. Parameters: EffectorIndex \u2014 - the index of the effector (as returned from AddEffector) Alpha \u2014 - used to blend the effect of the effector on/off. Ranges from 0 to 1. PullWeight \u2014 - determines the degree of effect this effector has on the rest of the body. Normalized relative to all other PullWeight values. NormalizePulling \u2014 - if True, total PullWeight on body is normalized to 1 to avoid over/under shooting. PositivePullFactor \u2014 - multiplies effect of this effector on the rest of the body in the positive directions NegativePullFactor \u2014 - multiplies effect of this effector on the rest of the body in the negative directions Returns: - SUCCESS or OUT_OF_BOUNDS if EffectorIndex is invalid","title":"PowerIKErrorCode SetEffectorWeights(   const int EffectorIndex,   const float Alpha,   const float PullWeight,   const bool NormalizePulling,   const Vec3&amp; PositivePullFactor,   const Vec3&amp; NegativePullFactor) const"},{"location":"sdk/solver/#powerikerrorcode-seteffectorsettings-const-int-effectorindex-const-float-deltasmoothspeed-const-bool-affectscenterofgravity-const","text":"Optionally call this every tick, for each effector, before Solve() to update the effector weight settings. Parameters: EffectorIndex \u2014 - the index of the effector (as returned from AddEffector) DeltaSmoothSpeed \u2014 - speed in centimeters per second that this effector adjusts to changing ground height. AffectsCenterOfGravity \u2014 - multiplies effect of this effector on the rest of the body in the negative directions Returns: - SUCCESS or OUT_OF_BOUNDS if EffectorIndex is invalid","title":"PowerIKErrorCode SetEffectorSettings(   const int EffectorIndex,   const float DeltaSmoothSpeed,   const bool AffectsCenterOfGravity) const"},{"location":"sdk/solver/#powerikerrorcode-seteffectorsmoothing-const-int-effectorindex-const-effectorsmoothingsettings-settings-const","text":"Optionally call this to smooth an effector's position and/or rotation over time Parameters: EffectorIndex \u2014 - the index of the effector (as returned from AddEffector) Settings \u2014 - the position and rotation smoothing settings Returns: - SUCCESS or OUT_OF_BOUNDS if EffectorIndex is invalid","title":"PowerIKErrorCode SetEffectorSmoothing(   const int EffectorIndex,   const EffectorSmoothingSettings&amp; Settings) const"},{"location":"sdk/solver/#powerikerrorcode-seteffectorpolevector-const-int-effectorindex-const-effectorpolevector-polevector-const","text":"Optionally call this to specify an Effector's pole vector settings Parameters: EffectorIndex \u2014 - the index of the effector (as returned from AddEffector) PoleVector \u2014 - the settings defining the Pole Vector behavior Returns: - SUCCESS or OUT_OF_BOUNDS if EffectorIndex is invalid","title":"PowerIKErrorCode SetEffectorPoleVector(   const int EffectorIndex,   const EffectorPoleVector&amp; PoleVector) const"},{"location":"sdk/solver/#powerikerrorcode-setbonebenddirection-const-int-boneindex-const-vec3-direction-const","text":"Optionally call this to specify a custom bending direction for a single bone Parameters: BoneIndex \u2014 - the index of the bone (as passed to AddBone) Direction \u2014 - a 3d vector in the local space of the bone that is the direction the bone will move in when bending Returns: - SUCCESS or OUT_OF_BOUNDS if BoneIndex is invalid","title":"PowerIKErrorCode SetBoneBendDirection(   const int BoneIndex,   const Vec3&amp; Direction) const"},{"location":"sdk/solver/#powerikerrorcode-setbonelimits-const-int-boneindex-const-float-stiffness-const-bool-uselimits-const-vec3-minangles-const-vec3-maxangles-const-bool-negatexaxis-const","text":"EXPERIMENTAL! Optionally call this to specify a set of limits and stiffness for a bone Parameters: BoneIndex \u2014 - the index of the bone (as passed to AddBone) Stiffness \u2014 - ranges from 0 to 1. Default is 0. At 1 the bone is completely rigid and will be removed from the solve entirely. UseLimits \u2014 - turn limits on/off. MinAngles \u2014 - minimum allowable X, Y and Z rotations relative to parent MaxAngles \u2014 - maximum allowable X, Y and Z rotations relative to parent NegateXAxis \u2014 - consider limits in opposite direction along X-axis Returns: - SUCCESS or OUT_OF_BOUNDS if BoneIndex is invalid","title":"PowerIKErrorCode SetBoneLimits(   const int BoneIndex,   const float Stiffness,   const bool UseLimits,   const Vec3&amp; MinAngles,   const Vec3&amp; MaxAngles,   const bool NegateXAxis) const"},{"location":"sdk/solver/#powerikerrorcode-getbonelimits-const-int-boneindex-vec3-outminlimits-vec3-outmaxlimits-bool-outnegatexaxis-bool-haslimits-const","text":"Optionally call this to get the limits for a bone. If the bone has no limits Parameters: BoneIndex \u2014 - the index of the bone OutMinLimits \u2014 - minimum allowable X, Y and Z rotations relative to parent OutMaxLimits \u2014 - maximum allowable X, Y and Z rotations relative to parent OutNegateXAxis \u2014 - consider limits in opposite direction along X-axis HasLimits \u2014 - True if the bone has limits, false otherwise (all Out values will be untouched) Returns: - SUCCESS or OUT_OF_BOUNDS if BoneIndex is invalid","title":"PowerIKErrorCode GetBoneLimits(   const int BoneIndex,   Vec3&amp; OutMinLimits,   Vec3&amp; OutMaxLimits,   bool&amp; OutNegateXAxis,   bool&amp; HasLimits) const"},{"location":"sdk/solver/#powerikerrorcode-excludeboneconst-int-boneindex-const","text":"Exclude the given bone. It will be treated as 100% stiff and the solver will ignore it. Parameters: BoneIndex \u2014 - the index of the bone (as passed to AddBone) Returns: - SUCCESS or OUT_OF_BOUNDS if BoneIndex is invalid","title":"PowerIKErrorCode ExcludeBone(const int BoneIndex) const"},{"location":"sdk/solver/#void-translateskeletonbeforesolveconst-vec3-positionoffset-const","text":"Convenience method for providing global offsets to the skeleton to be applied internally before the main solver pass. Parameters: PositionOffset \u2014 - the amount to translate the entire skeleton","title":"void TranslateSkeletonBeforeSolve(const Vec3&amp; PositionOffset) const"},{"location":"sdk/solver/#void-rotateskeletonbeforesolveconst-quat-rotationoffset-const","text":"Convenience method for providing global offsets to the skeleton to be applied internally before the main solver pass. Parameters: RotationOffset \u2014 - the amount to rotate the entire skeleton","title":"void RotateSkeletonBeforeSolve(const Quat&amp; RotationOffset) const"},{"location":"sdk/solver/#powerikerrorcode-rotatebonebeforesolve-const-quat-rotationoffset-const-int-boneindex-const","text":"Convenience method for providing local rotate offsets to specific bones to be applied internally before the main solver pass. Parameters: RotationOffset \u2014 - character space rotation offset applied relative to input pose BoneIndex \u2014 - the index of the bone (as passed to AddBone) Returns: - SUCCESS or OUT_OF_BOUNDS if BoneIndex is invalid","title":"PowerIKErrorCode RotateBoneBeforeSolve(   const Quat&amp; RotationOffset,   const int BoneIndex) const"},{"location":"unreal/bend_directions/","text":"Bend Directions By default, Power IK will bend limbs in the direction that they are bent in the input pose. Sometimes the input pose does not give a good enough hint of which direction to bend in. So the solver must be supplied with an explicit Bend Direction. If knees and elbows are observed bending off-axis, chances are custom Bend Directions must be supplied. Specify a Custom Bend Direction Determine the name of the bone that is bending in the wrong direction. This can be found in the Skeleton editor in Unreal. Determine what local axis (in bone space) that points in the direction the limb should bend. For example, if the Y axis points in the direction of the knee, the bend vector is 0, 1, 0. Make note of this vector. Select the Power IK Solver node and in the detail panel locate the Constraints section. Click the + icon next to Bend Directions to add a new Bend Direction to the array. Add the Bone Name and Bend Direction vector. Save and compile the animation blueprint. The specified bone will now bend in the direction of the vector. The following image shows the custom bend directions appropriate for the Unreal Mannequin. Notice that the Right side bones have their vectors negated. How to Determine the Bend Vector These vectors can be discovered by selecting the bone in the skeleton editor and observing the axis that points in the direction the bone should bend. In the image below the Mannequin's left knee should point in the positive Y direction, so the bend vector is (0, 1, 0).","title":"Bend Directions"},{"location":"unreal/bend_directions/#bend-directions","text":"By default, Power IK will bend limbs in the direction that they are bent in the input pose. Sometimes the input pose does not give a good enough hint of which direction to bend in. So the solver must be supplied with an explicit Bend Direction. If knees and elbows are observed bending off-axis, chances are custom Bend Directions must be supplied.","title":"Bend Directions"},{"location":"unreal/bend_directions/#specify-a-custom-bend-direction","text":"Determine the name of the bone that is bending in the wrong direction. This can be found in the Skeleton editor in Unreal. Determine what local axis (in bone space) that points in the direction the limb should bend. For example, if the Y axis points in the direction of the knee, the bend vector is 0, 1, 0. Make note of this vector. Select the Power IK Solver node and in the detail panel locate the Constraints section. Click the + icon next to Bend Directions to add a new Bend Direction to the array. Add the Bone Name and Bend Direction vector. Save and compile the animation blueprint. The specified bone will now bend in the direction of the vector. The following image shows the custom bend directions appropriate for the Unreal Mannequin. Notice that the Right side bones have their vectors negated.","title":"Specify a Custom Bend Direction"},{"location":"unreal/bend_directions/#how-to-determine-the-bend-vector","text":"These vectors can be discovered by selecting the bone in the skeleton editor and observing the axis that points in the direction the bone should bend. In the image below the Mannequin's left knee should point in the positive Y direction, so the bend vector is (0, 1, 0).","title":"How to Determine the Bend Vector"},{"location":"unreal/center_of_gravity/","text":"Center of Gravity Constraint The Center of Gravity Constraint operates on the Character Root bone (typically the pelvis or hips). It works to pull the hips back over the center of gravity when other body parts (like the head or hands) are trying to pull it off-center. This was developed for creating 3-point VR tracking rigs. But may be useful in other scenarios as well. The center of gravity is defined as the average position of any effectors with the \"Affects Center of Gravity\" flag turned on. To enable Center of Gravity: Add an Effector to each foot. Set Affects Center of Gravity on for all the foot effectors. In the Solver node, set the Center of Gravity Alpha value to 1.0. Test the setup by pulling the hips off center. The attributes of the contraint are important for tuning the effect: Alpha : a global blend of the effect, 0 is off (and computation is skipped) Horiz Amount : this is the amount that the hips compensate in the opposite direction they are being pulled. A value of 1.0 will pin the hips (horizontally) to the center of gravity. Values greater than one will push the hip in the opposite direction which can give the impression of keeping the overall body balanced. Vert Amount : this is the amount that the hips are raised up when pulled down and off-center. This forces a biped into a bent-over pose instead of a crouched leaning pose. This tends to look more natural when leaning down. This has to be tuned depending on the shape of the character's body. Pull Body Amount : This controls how much the pelvis will pull the rest of the body back towards the center of gravity. At low values, it will yank the pelvis back while leaving the torso looking unnaturally vertical and kinked. The default value works good for humans.","title":"Center of Gravity"},{"location":"unreal/center_of_gravity/#center-of-gravity-constraint","text":"The Center of Gravity Constraint operates on the Character Root bone (typically the pelvis or hips). It works to pull the hips back over the center of gravity when other body parts (like the head or hands) are trying to pull it off-center. This was developed for creating 3-point VR tracking rigs. But may be useful in other scenarios as well. The center of gravity is defined as the average position of any effectors with the \"Affects Center of Gravity\" flag turned on. To enable Center of Gravity: Add an Effector to each foot. Set Affects Center of Gravity on for all the foot effectors. In the Solver node, set the Center of Gravity Alpha value to 1.0. Test the setup by pulling the hips off center. The attributes of the contraint are important for tuning the effect: Alpha : a global blend of the effect, 0 is off (and computation is skipped) Horiz Amount : this is the amount that the hips compensate in the opposite direction they are being pulled. A value of 1.0 will pin the hips (horizontally) to the center of gravity. Values greater than one will push the hip in the opposite direction which can give the impression of keeping the overall body balanced. Vert Amount : this is the amount that the hips are raised up when pulled down and off-center. This forces a biped into a bent-over pose instead of a crouched leaning pose. This tends to look more natural when leaning down. This has to be tuned depending on the shape of the character's body. Pull Body Amount : This controls how much the pelvis will pull the rest of the body back towards the center of gravity. At low values, it will yank the pelvis back while leaving the torso looking unnaturally vertical and kinked. The default value works good for humans.","title":"Center of Gravity Constraint"},{"location":"unreal/common_issues/","text":"Common Issues Report Bugs For the fastest response, including community help, please post your issue in the official Power IK discord channel . If you are having trouble using Power IK, or you encounter issues or bugs, please send a detailed account of the issue to: support@poweranimated.com . We will do our best to make sure Power IK is working for you. \u201cI don\u2019t see any effect on my skeleton.\u201d There may be several reasons for this: Check the Output Log for warnings. It could be that the Solver node was not able to find the Character Root, Ground Plane Bone or one of the Effector bones. Check that you have the correct animation blueprint running on your actor. Check that the Power IK Solver has it\u2019s input and output poses plugged in. Check that you are actually telling the effectors to move. By default they are set to Relative to Input Pose with a translation and rotation of zero. This has no effect on your skeleton! \u201cMy character disappears after adding Power IK.\u201d When using World Space effectors, it\u2019s possible to pull your character very far away from their capsule. Check the values going into the translation channel of the effectors and make sure you aren\u2019t yanking the character back to the origin or to some far off place in space. Also you make need to put a small delay after Spawn (0.2 seconds) to allow time for your animation systems initialize. If Power IK recieves world space values of zero, it can throw the model back to the world origin, which can cause the LOD system to cull the actor. \u201cMy limbs are bending in the wrong direction.\u201d Power IK needs a hint of what direction to bend in. If you supply a perfectly straight input pose it may choose a bending angle which \u201cbreaks\u201d your character. You have two options to fix this: Supply an input pose that has at least some bend in it. Specify a custom Bend Direction","title":"Common Issues"},{"location":"unreal/common_issues/#common-issues","text":"","title":"Common Issues"},{"location":"unreal/common_issues/#report-bugs","text":"For the fastest response, including community help, please post your issue in the official Power IK discord channel . If you are having trouble using Power IK, or you encounter issues or bugs, please send a detailed account of the issue to: support@poweranimated.com . We will do our best to make sure Power IK is working for you.","title":"Report Bugs"},{"location":"unreal/common_issues/#i-dont-see-any-effect-on-my-skeleton","text":"There may be several reasons for this: Check the Output Log for warnings. It could be that the Solver node was not able to find the Character Root, Ground Plane Bone or one of the Effector bones. Check that you have the correct animation blueprint running on your actor. Check that the Power IK Solver has it\u2019s input and output poses plugged in. Check that you are actually telling the effectors to move. By default they are set to Relative to Input Pose with a translation and rotation of zero. This has no effect on your skeleton!","title":"\u201cI don\u2019t see any effect on my skeleton.\u201d"},{"location":"unreal/common_issues/#my-character-disappears-after-adding-power-ik","text":"When using World Space effectors, it\u2019s possible to pull your character very far away from their capsule. Check the values going into the translation channel of the effectors and make sure you aren\u2019t yanking the character back to the origin or to some far off place in space. Also you make need to put a small delay after Spawn (0.2 seconds) to allow time for your animation systems initialize. If Power IK recieves world space values of zero, it can throw the model back to the world origin, which can cause the LOD system to cull the actor.","title":"\u201cMy character disappears after adding Power IK.\u201d"},{"location":"unreal/common_issues/#my-limbs-are-bending-in-the-wrong-direction","text":"Power IK needs a hint of what direction to bend in. If you supply a perfectly straight input pose it may choose a bending angle which \u201cbreaks\u201d your character. You have two options to fix this: Supply an input pose that has at least some bend in it. Specify a custom Bend Direction","title":"\u201cMy limbs are bending in the wrong direction.\u201d"},{"location":"unreal/control_rig/","text":"Control Rig with Power IK The Unreal Control Rig plugin allows the creation of user controlled animation rigs directly in the Unreal Editor. Control Rigs can be used to: Create keyframed animation sequences by animating \"control\" objects Create procedural effects that run in the Anim Graph using the Control Rig Anim Graph node See the official Control Rig Documentation for more information. Power IK provides full access to the Power IK solver directly in a Control Rig graph. This allows for the creation of sophisticated full-body IK rigs that users can interact with, animate and even drive dynamically at run-time. Video Tutorials The easiest way to understand how Control Rig works is to see it in action. Check out our two part tutorial series on using Control Rig with Power IK: In Part 1 , we are given an overview of an advanced Spider rig in Control Rig that uses a layered Power IK setup to create an auto-additive thorax control complete with dynamics. In Part 2 , we create a Spider Control Rig from scratch, add a root control and then rig up the legs to be controlled with Power IK. How to Drive Control Rigs At Runtime Control Rig assets can be used to perform an operation on an input pose, to produce a new output pose. You can embed them in Unreal's Anim Graph do to procedural modifications using Vector or float variables. Vector variables may come from other Components, Event Graphs or blueprint logic. You can use normal Control rig \"Controls\" for debugging, testing and keyframe animation. When you want to drive an effect procedurally from gameplay code or blueprint, convert the Effector inputs to parameters and expose them using this method. Open a Control Rig blueprint : Right-click in the Rig Graph and get a variable of type \"vector\". Plug the vector parameter into an effector position. Name the vector parameter. Now open an Anim Graph : Create a Control Rig node. Set the class to the Control Rig blueprint. Observe the named blueprint parameters in the details. Click the Use Pin checkbox to expose the parameter as a pin. Connect a Vector variable to the Anim Graph pin.","title":"Control Rig"},{"location":"unreal/control_rig/#control-rig-with-power-ik","text":"The Unreal Control Rig plugin allows the creation of user controlled animation rigs directly in the Unreal Editor. Control Rigs can be used to: Create keyframed animation sequences by animating \"control\" objects Create procedural effects that run in the Anim Graph using the Control Rig Anim Graph node See the official Control Rig Documentation for more information. Power IK provides full access to the Power IK solver directly in a Control Rig graph. This allows for the creation of sophisticated full-body IK rigs that users can interact with, animate and even drive dynamically at run-time.","title":"Control Rig with Power IK"},{"location":"unreal/control_rig/#video-tutorials","text":"The easiest way to understand how Control Rig works is to see it in action. Check out our two part tutorial series on using Control Rig with Power IK: In Part 1 , we are given an overview of an advanced Spider rig in Control Rig that uses a layered Power IK setup to create an auto-additive thorax control complete with dynamics. In Part 2 , we create a Spider Control Rig from scratch, add a root control and then rig up the legs to be controlled with Power IK.","title":"Video Tutorials"},{"location":"unreal/control_rig/#how-to-drive-control-rigs-at-runtime","text":"Control Rig assets can be used to perform an operation on an input pose, to produce a new output pose. You can embed them in Unreal's Anim Graph do to procedural modifications using Vector or float variables. Vector variables may come from other Components, Event Graphs or blueprint logic. You can use normal Control rig \"Controls\" for debugging, testing and keyframe animation. When you want to drive an effect procedurally from gameplay code or blueprint, convert the Effector inputs to parameters and expose them using this method. Open a Control Rig blueprint : Right-click in the Rig Graph and get a variable of type \"vector\". Plug the vector parameter into an effector position. Name the vector parameter. Now open an Anim Graph : Create a Control Rig node. Set the class to the Control Rig blueprint. Observe the named blueprint parameters in the details. Click the Use Pin checkbox to expose the parameter as a pin. Connect a Vector variable to the Anim Graph pin.","title":"How to Drive Control Rigs At Runtime"},{"location":"unreal/debugging/","text":"Debugging Power IK Gaining insight into what Power IK is doing is crucial to helping you design a functional IK rig. Anim Graph Debug View When setting up Power IK in the Animation Graph, it will show yellow diamonds in the preview window demonstrating which bones have effectors attached to them. Select the Power IK solver node to see the debug view. Note: If the yellow diamonds are not showing up, double-check that the bone names set correctly on the effector inputs, and that the solver is plugged into the graph (input and output pose). The size of the debug drawing can be tuned for better visibility: Play In Editor Debug View While playing in editor, hit ~ to bring up the console and execute the command: showdebug ANIMATION Then use the Page Up/Down to cycle through the anim instances in the scene. This provides some information about what Power IK is doing. PowerIK draws blue diamonds on each effector, as well as a print out showing how many effectors the solver is running and their current Alpha values.","title":"Debugging"},{"location":"unreal/debugging/#debugging-power-ik","text":"Gaining insight into what Power IK is doing is crucial to helping you design a functional IK rig.","title":"Debugging Power IK"},{"location":"unreal/debugging/#anim-graph-debug-view","text":"When setting up Power IK in the Animation Graph, it will show yellow diamonds in the preview window demonstrating which bones have effectors attached to them. Select the Power IK solver node to see the debug view. Note: If the yellow diamonds are not showing up, double-check that the bone names set correctly on the effector inputs, and that the solver is plugged into the graph (input and output pose). The size of the debug drawing can be tuned for better visibility:","title":"Anim Graph Debug View"},{"location":"unreal/debugging/#play-in-editor-debug-view","text":"While playing in editor, hit ~ to bring up the console and execute the command: showdebug ANIMATION Then use the Page Up/Down to cycle through the anim instances in the scene. This provides some information about what Power IK is doing. PowerIK draws blue diamonds on each effector, as well as a print out showing how many effectors the solver is running and their current Alpha values.","title":"Play In Editor Debug View"},{"location":"unreal/effector_settings/","text":"Effectors What is a Power IK Effector? Effectors are how you tell the solver what bone of the skeleton you want to pull, and where you want it to go. Each effector is associated with a single bone in the skeleton and supplies a position and rotation for that bone to reach towards. If only 1 effector is added, it will pull the entire skeleton as though the skeleton were parented to it. Once multiple effectors are present, the solver is able to do interesting work by creating a pose that reaches both effectors simultaneously. For example, by adding an effector to both feet of an ogre, you can pull 1 foot upwards while leaving the other foot on the ground. The hips of the ogre will translate and rotate to help the overall skeleton reach this desired goal. Bone Name This is the name of the bone that this effector will affect. The name in this field must match the name in the skeleton precisely. Bones cannot be affected by more than 1 effector. NOTE : As of v1.47 there may be a bug that requires the Effector bone name to be specified in all lowercase, even if the bone name is uppercase in the skeleton. This will be fixed in a future update. Position and Rotation Space The Position (Vector) and Rotation (Rotator) inputs are considered to be in one of three possible spaces: Relative to Input Pose : interprets inputs as character-space offsets relative to the affected bone in the pose that is passed as input. This is the default space. World Space : interprets inputs as world space. Component Space : interprets inputs as being relative to the root of the Skeletal Mesh. Relative To Input Pose By default, the space of the effector is Relative to Input Pose with zero position and rotation values. This is essentially telling the solver to not modify the input pose (ie do nothing). All three spaces are useful in different scenarios. But the most common is Relative to Input Pose . This can be used to nudge the skeleton from it\u2019s animated position. For example, by taking a walking animation and pulling the feel outwards and the hips down you can turn a walk into a crouch-walk. Space Conversions Blueprint and C++ can easily convert rotations and positions between any space in Unreal. The Component Space and World Space options are simply conveniences. Internally, the IK solver uses only Component Space (called Character Space in the SDK). Separate Position / Rotation Spaces As of v1.46 Power IK supports separate spaces for position and rotation. This is especially useful for rotating a skeleton while leaving it's position unaffected (by leaving it zero relative to the input pose). This is the basis of a \"look at\" rig. Pull Weight The Pull Weight of an effector determines how much influence the effector has over the whole body relative to other effectors . If all the Pull Weight values are the same, they all have the same relative influence on the skeleton. This is regardless of their absolute values. In cases where you want simple reaching behavior, leaving all the Pull Weights set to 1.0 will split the influence of the effectors evenly. Power IK weights the unaffected parts of the skeleton based on distance (along the skeleton) to the effectors. This provides decent influence distribution by default. Adjusting Pull Weights is sometimes necessary in situations where one part of the body needs to dominate the pose. For example, to setup a 3-point VR tracking solver, tune 100% of the weight on the head tracker and 0% on the hands. This will cause the hands to not push the torso around and instead have the hips and torso follow the head. Normalize Pulling This checkbox is on by default. When on, the skeleton will move with the effectors completely; neither over or under shooting. The influence of the effectors on the bones is 'normalized'. But in some cases it may be desirable not to have normalized influence. Either because the character at large is moved by other means, or the desired behavior should be localized to some sub-section of the skeleton. More precise control over the influence can be achieved by setting \"Normalize Pulling\" to OFF. Now the effector will pull on the body proportional to the Pull Weight multiplied by the inverse distance to the body part. This is especially useful in conjuction with Positive and Negative Pull Factors. Positive/Negative Pull Factors The Positive and Negative Pull Factors supply two 3d vectors to allow scaling the influence of an effector along all three axes in both the positive and negative directions. Negative Pull Factors were used in the \"Prone Mannequin\" example to allow the mannequin to prefer reaching when tilted downwards, and lie flat when tilted upwards. This non-linear behavior is achieved by giving the hands a low negative pull factor in the Z direction (up/down). So the influence they have on the body is greater in the positive Z direction and less in the negative Z. Rotate Bone Rotate Bone is checked off by default. When off, the bone will simply inherit the rotation of it's parent. When on, the bone matches the rotation of the effector. Both are useful depending on the situation. Rotate Limb Rotate Limb is off by default. When on, the effector rotation will be smoothly distributed up the limb. This is useful for spines and look-at behaviors. Rotate Limb is demonstrated on the hanging snake demo in the Unreal examples project. Delta Smooth Speed This value determines how quickly the Effector adapts to the position and rotation values coming into it in a way that does not dampen or lag the input animation. Internally, a delta between the animated position and the effector position is maintained across time. This delta is applied over time on top of the existing animation. This way large variations in the Effector input positions are applied gradually ontop of the input animation. Smoothing Effector positions can be smoothed in world space to prevent sharp accelerations. See the page on Effector Smoothing for more details. Pole Vector So called Pole Vectors are used to provide explicit control over the orientation of limbs controlled by effectors. You can control the rotation of limbs above an Effector using one of four modes: None : The limb will bend and rotate freely (this is the default). Character Space Position : This uses the input vector to supply a location in Character Space that represents the direction the limb should aim at. The angle of the limb is recorded relative to this position when the solver is initialized, so only changes in this position will cause the limb to rotate. Bone : Works identically to the Character Space Position setting except the position is derived directly from another bone in the skeleton. This is useful if you want to animate the pole vector location in a content creation package (like Maya) and use that in the game. Float Angle Offset : This uses the Angle Offset float parameter to rotate the limb by an angle. This can be useful if you need to nudge the limb inwards or outwards. Note : As of v1.5, the Pole Vector features are brand new and thus considered experimental. While there are no known issues, it has not been thoroughly tested yet. Please report any issues to support@poweranimated.com. Alpha This value ranges from 0 to 1 and set to 1 by default. The Alpha value blends the influence of this effector on/off. This can be easier than blending the target transforms. For example, to animate a character opening a door, the effector position may be left at the location of the door knob, and the alpha value may be blended off/on/off throughout the duration of the reach animation. This is easier than blending the target position.","title":"Effector Settings"},{"location":"unreal/effector_settings/#effectors","text":"","title":"Effectors"},{"location":"unreal/effector_settings/#what-is-a-power-ik-effector","text":"Effectors are how you tell the solver what bone of the skeleton you want to pull, and where you want it to go. Each effector is associated with a single bone in the skeleton and supplies a position and rotation for that bone to reach towards. If only 1 effector is added, it will pull the entire skeleton as though the skeleton were parented to it. Once multiple effectors are present, the solver is able to do interesting work by creating a pose that reaches both effectors simultaneously. For example, by adding an effector to both feet of an ogre, you can pull 1 foot upwards while leaving the other foot on the ground. The hips of the ogre will translate and rotate to help the overall skeleton reach this desired goal.","title":"What is a Power IK Effector?"},{"location":"unreal/effector_settings/#bone-name","text":"This is the name of the bone that this effector will affect. The name in this field must match the name in the skeleton precisely. Bones cannot be affected by more than 1 effector. NOTE : As of v1.47 there may be a bug that requires the Effector bone name to be specified in all lowercase, even if the bone name is uppercase in the skeleton. This will be fixed in a future update.","title":"Bone Name"},{"location":"unreal/effector_settings/#position-and-rotation-space","text":"The Position (Vector) and Rotation (Rotator) inputs are considered to be in one of three possible spaces: Relative to Input Pose : interprets inputs as character-space offsets relative to the affected bone in the pose that is passed as input. This is the default space. World Space : interprets inputs as world space. Component Space : interprets inputs as being relative to the root of the Skeletal Mesh.","title":"Position and Rotation Space"},{"location":"unreal/effector_settings/#relative-to-input-pose","text":"By default, the space of the effector is Relative to Input Pose with zero position and rotation values. This is essentially telling the solver to not modify the input pose (ie do nothing). All three spaces are useful in different scenarios. But the most common is Relative to Input Pose . This can be used to nudge the skeleton from it\u2019s animated position. For example, by taking a walking animation and pulling the feel outwards and the hips down you can turn a walk into a crouch-walk.","title":"Relative To Input Pose"},{"location":"unreal/effector_settings/#space-conversions","text":"Blueprint and C++ can easily convert rotations and positions between any space in Unreal. The Component Space and World Space options are simply conveniences. Internally, the IK solver uses only Component Space (called Character Space in the SDK).","title":"Space Conversions"},{"location":"unreal/effector_settings/#separate-position-rotation-spaces","text":"As of v1.46 Power IK supports separate spaces for position and rotation. This is especially useful for rotating a skeleton while leaving it's position unaffected (by leaving it zero relative to the input pose). This is the basis of a \"look at\" rig.","title":"Separate Position / Rotation Spaces"},{"location":"unreal/effector_settings/#pull-weight","text":"The Pull Weight of an effector determines how much influence the effector has over the whole body relative to other effectors . If all the Pull Weight values are the same, they all have the same relative influence on the skeleton. This is regardless of their absolute values. In cases where you want simple reaching behavior, leaving all the Pull Weights set to 1.0 will split the influence of the effectors evenly. Power IK weights the unaffected parts of the skeleton based on distance (along the skeleton) to the effectors. This provides decent influence distribution by default. Adjusting Pull Weights is sometimes necessary in situations where one part of the body needs to dominate the pose. For example, to setup a 3-point VR tracking solver, tune 100% of the weight on the head tracker and 0% on the hands. This will cause the hands to not push the torso around and instead have the hips and torso follow the head.","title":"Pull Weight"},{"location":"unreal/effector_settings/#normalize-pulling","text":"This checkbox is on by default. When on, the skeleton will move with the effectors completely; neither over or under shooting. The influence of the effectors on the bones is 'normalized'. But in some cases it may be desirable not to have normalized influence. Either because the character at large is moved by other means, or the desired behavior should be localized to some sub-section of the skeleton. More precise control over the influence can be achieved by setting \"Normalize Pulling\" to OFF. Now the effector will pull on the body proportional to the Pull Weight multiplied by the inverse distance to the body part. This is especially useful in conjuction with Positive and Negative Pull Factors.","title":"Normalize Pulling"},{"location":"unreal/effector_settings/#positivenegative-pull-factors","text":"The Positive and Negative Pull Factors supply two 3d vectors to allow scaling the influence of an effector along all three axes in both the positive and negative directions. Negative Pull Factors were used in the \"Prone Mannequin\" example to allow the mannequin to prefer reaching when tilted downwards, and lie flat when tilted upwards. This non-linear behavior is achieved by giving the hands a low negative pull factor in the Z direction (up/down). So the influence they have on the body is greater in the positive Z direction and less in the negative Z.","title":"Positive/Negative Pull Factors"},{"location":"unreal/effector_settings/#rotate-bone","text":"Rotate Bone is checked off by default. When off, the bone will simply inherit the rotation of it's parent. When on, the bone matches the rotation of the effector. Both are useful depending on the situation.","title":"Rotate Bone"},{"location":"unreal/effector_settings/#rotate-limb","text":"Rotate Limb is off by default. When on, the effector rotation will be smoothly distributed up the limb. This is useful for spines and look-at behaviors. Rotate Limb is demonstrated on the hanging snake demo in the Unreal examples project.","title":"Rotate Limb"},{"location":"unreal/effector_settings/#delta-smooth-speed","text":"This value determines how quickly the Effector adapts to the position and rotation values coming into it in a way that does not dampen or lag the input animation. Internally, a delta between the animated position and the effector position is maintained across time. This delta is applied over time on top of the existing animation. This way large variations in the Effector input positions are applied gradually ontop of the input animation.","title":"Delta Smooth Speed"},{"location":"unreal/effector_settings/#smoothing","text":"Effector positions can be smoothed in world space to prevent sharp accelerations. See the page on Effector Smoothing for more details.","title":"Smoothing"},{"location":"unreal/effector_settings/#pole-vector","text":"So called Pole Vectors are used to provide explicit control over the orientation of limbs controlled by effectors. You can control the rotation of limbs above an Effector using one of four modes: None : The limb will bend and rotate freely (this is the default). Character Space Position : This uses the input vector to supply a location in Character Space that represents the direction the limb should aim at. The angle of the limb is recorded relative to this position when the solver is initialized, so only changes in this position will cause the limb to rotate. Bone : Works identically to the Character Space Position setting except the position is derived directly from another bone in the skeleton. This is useful if you want to animate the pole vector location in a content creation package (like Maya) and use that in the game. Float Angle Offset : This uses the Angle Offset float parameter to rotate the limb by an angle. This can be useful if you need to nudge the limb inwards or outwards. Note : As of v1.5, the Pole Vector features are brand new and thus considered experimental. While there are no known issues, it has not been thoroughly tested yet. Please report any issues to support@poweranimated.com.","title":"Pole Vector"},{"location":"unreal/effector_settings/#alpha","text":"This value ranges from 0 to 1 and set to 1 by default. The Alpha value blends the influence of this effector on/off. This can be easier than blending the target transforms. For example, to animate a character opening a door, the effector position may be left at the location of the door knob, and the alpha value may be blended off/on/off throughout the duration of the reach animation. This is easier than blending the target position.","title":"Alpha"},{"location":"unreal/effector_smoothing/","text":"Effector Smoothing Power IK comes with built-in temporal smoothing to help reduce pops and jitters in fast moving effector inputs. You can apply your own smoothing to the inputs to Power IK effectors, but the built-in smoothing has some advantages: does not introduce non-linear accelerations where there are non in the input clamps positions and rotations to within a threshold distance / angle To enable Effector Smoothing: Select an Effector node in the Animation Graph Drag off the Smoothing pin to create a PowerIKSmoothing struct Toggle the settings as desired. Smoothing Settings Smooth Position Over Time : bool, if True the position of the effector will be smoothed over time. Max Position Speed : this is the maximum speed, in centimeters per second, that the effector is allowed to move. If an input is provided that moves the effector faster than this speed, it will be clamped. Max Position Distance : this is the maximum distance, in centimeters, that the effector will be allowed to lag behind the input position. This limits the error that can be introduced from position smoothing. And similarly for smoothing rotations: Smooth Rotation Over Time : bool, if True the rotation of the effector will be smoothed over time. Max Degrees Speed : this is the maximum speed, in degrees per second, that the effector is allowed to rotate. If an input is provided that rotates the effector faster than this speed, it will be clamped. Max Degrees Distance : this is the maximum angle, in degrees, that the effector will be allowed to lag behind the input rotation. This limits the error that can be introduced from rotation smoothing. Global Smoothing All the smoothing settings may be globally adjusted on the solver node itself. The Smoothing Max Speed Multiplier and Smoothing Max Distance Multiplier are set to 1.0 by default. These values are multplied by the Effector settings to arrive at the final smoothing value.","title":"Effector Smoothing"},{"location":"unreal/effector_smoothing/#effector-smoothing","text":"Power IK comes with built-in temporal smoothing to help reduce pops and jitters in fast moving effector inputs. You can apply your own smoothing to the inputs to Power IK effectors, but the built-in smoothing has some advantages: does not introduce non-linear accelerations where there are non in the input clamps positions and rotations to within a threshold distance / angle To enable Effector Smoothing: Select an Effector node in the Animation Graph Drag off the Smoothing pin to create a PowerIKSmoothing struct Toggle the settings as desired.","title":"Effector Smoothing"},{"location":"unreal/effector_smoothing/#smoothing-settings","text":"Smooth Position Over Time : bool, if True the position of the effector will be smoothed over time. Max Position Speed : this is the maximum speed, in centimeters per second, that the effector is allowed to move. If an input is provided that moves the effector faster than this speed, it will be clamped. Max Position Distance : this is the maximum distance, in centimeters, that the effector will be allowed to lag behind the input position. This limits the error that can be introduced from position smoothing. And similarly for smoothing rotations: Smooth Rotation Over Time : bool, if True the rotation of the effector will be smoothed over time. Max Degrees Speed : this is the maximum speed, in degrees per second, that the effector is allowed to rotate. If an input is provided that rotates the effector faster than this speed, it will be clamped. Max Degrees Distance : this is the maximum angle, in degrees, that the effector will be allowed to lag behind the input rotation. This limits the error that can be introduced from rotation smoothing.","title":"Smoothing Settings"},{"location":"unreal/effector_smoothing/#global-smoothing","text":"All the smoothing settings may be globally adjusted on the solver node itself. The Smoothing Max Speed Multiplier and Smoothing Max Distance Multiplier are set to 1.0 by default. These values are multplied by the Effector settings to arrive at the final smoothing value.","title":"Global Smoothing"},{"location":"unreal/getting_started_unreal/","text":"Getting the Power IK Unreal Plugin The Power IK Unreal Plugin can be purchased and installed through the Unreal Marketplace. Power IK Unreal Plugin is currently available only for Unreal 4.24 on Windows 64 bit. If you require a different version for a different platform, please contact support@poweranimated.com. Installation Engine Installation The fastest way to get started with Power IK is to purchase it from the Unreal Marketplace and use the Epic Games launcher to install it directly into the engine folder. Open the Epic Games launcher Click on Unreal Engine Click on Library Search the Vault for Power IK Click Install to Engine Now Launch the engine version that you installed Power IK to. Enable the Plugin In Unreal select Edit > Plugins Search for Power IK in the Animation category. Check Enabled Unreal will prompt you to restart the editor to load the plugin. After restarting, Power IK will be loaded and ready to use! Project Installation To install it manually, follow these steps: Download and unzip the PowerIK plugin. Copy the \\PowerIK directory to the MyProject/Plugins folder. Right click on the .uproject file and select Generate Visual Studio project files Build and launch the project as normal. Note: If you encounter an error when starting Unreal after installing Power IK, please check that the Visual Studio Prerequisites are installed for Unreal Engine. Missing dll errors (VCRUNTIME140_1.dll for example) are usually resolved by installing the Visual C++ Runtime . Quick Start To use Power IK, you need a Skeletal Mesh and an Animation Blueprint. This tutorial uses the Dino included in the Demo project. Right-click in the Content Browser to create an Animation Blueprint . Associate it with the Dino skeleton and name it ABP_Dino_Tutorial . Open the AnimGraph, right-click and create a Power IK Solver node. Set the Character Root to the top joint in your creature. Usually \u201chips\u201d or \u201cpelvis\u201d. For the Dino we use \u201cpelvis\u201d. This is not usually the absolute root of the Skeleton, but the top node in the creature\u2019s anatomy (the one that translates). Select the Power IK Solver node and in the details panel, click the \u201c+\u201d icon twice to make two Effectors. Right-click on the node and select Refresh Nodes to see the input pins for the Solver effectors. Click and drag one of the effector pins and select Make PowerIKEffector. Repeat for the second effector pin. Set the Bone Name field to the bone you want to touch the effector. For the Dino, we will grab both his feet: \u201cheel_l\u201d and \u201cheel_r\u201d. Connect the solver output to the Output Pose. Compile the anim blueprint. Then select the Power IK Solver node and observe in the viewport that both feet have yellow diamonds on them. These are the effectors. Open the \u201cheel_l\u201d Effector node and set the translation to 0, 0, 50. Then compile and observe new Effector location in the viewport: Drag the Skeletal Mesh asset into a level. In the details panel, set the Anim Class to the animation blueprint asset we just created: Now click Play. Observe that the left foot is reaching up, while the right foot remains planted on the ground. The pelvis, being free of any effectors, will automatically translate and rotate to help the feet reach the targets. Congratulations! Power IK is now setup and working. From here, you are ready to drive the positions and rotations of the effectors through blueprint. These transforms can come from any source. Sophisticated procedural animation systems can be built ontop of Power IK. For testing/debug purposes, you can create a PowerIK Interactive Rig which allows you to interactively pull your effector positions with the mouse.","title":"Getting Started"},{"location":"unreal/getting_started_unreal/#getting-the-power-ik-unreal-plugin","text":"The Power IK Unreal Plugin can be purchased and installed through the Unreal Marketplace. Power IK Unreal Plugin is currently available only for Unreal 4.24 on Windows 64 bit. If you require a different version for a different platform, please contact support@poweranimated.com.","title":"Getting the Power IK Unreal Plugin"},{"location":"unreal/getting_started_unreal/#installation","text":"","title":"Installation"},{"location":"unreal/getting_started_unreal/#engine-installation","text":"The fastest way to get started with Power IK is to purchase it from the Unreal Marketplace and use the Epic Games launcher to install it directly into the engine folder. Open the Epic Games launcher Click on Unreal Engine Click on Library Search the Vault for Power IK Click Install to Engine Now Launch the engine version that you installed Power IK to.","title":"Engine Installation"},{"location":"unreal/getting_started_unreal/#enable-the-plugin","text":"In Unreal select Edit > Plugins Search for Power IK in the Animation category. Check Enabled Unreal will prompt you to restart the editor to load the plugin. After restarting, Power IK will be loaded and ready to use!","title":"Enable the Plugin"},{"location":"unreal/getting_started_unreal/#project-installation","text":"To install it manually, follow these steps: Download and unzip the PowerIK plugin. Copy the \\PowerIK directory to the MyProject/Plugins folder. Right click on the .uproject file and select Generate Visual Studio project files Build and launch the project as normal. Note: If you encounter an error when starting Unreal after installing Power IK, please check that the Visual Studio Prerequisites are installed for Unreal Engine. Missing dll errors (VCRUNTIME140_1.dll for example) are usually resolved by installing the Visual C++ Runtime .","title":"Project Installation"},{"location":"unreal/getting_started_unreal/#quick-start","text":"To use Power IK, you need a Skeletal Mesh and an Animation Blueprint. This tutorial uses the Dino included in the Demo project. Right-click in the Content Browser to create an Animation Blueprint . Associate it with the Dino skeleton and name it ABP_Dino_Tutorial . Open the AnimGraph, right-click and create a Power IK Solver node. Set the Character Root to the top joint in your creature. Usually \u201chips\u201d or \u201cpelvis\u201d. For the Dino we use \u201cpelvis\u201d. This is not usually the absolute root of the Skeleton, but the top node in the creature\u2019s anatomy (the one that translates). Select the Power IK Solver node and in the details panel, click the \u201c+\u201d icon twice to make two Effectors. Right-click on the node and select Refresh Nodes to see the input pins for the Solver effectors. Click and drag one of the effector pins and select Make PowerIKEffector. Repeat for the second effector pin. Set the Bone Name field to the bone you want to touch the effector. For the Dino, we will grab both his feet: \u201cheel_l\u201d and \u201cheel_r\u201d. Connect the solver output to the Output Pose. Compile the anim blueprint. Then select the Power IK Solver node and observe in the viewport that both feet have yellow diamonds on them. These are the effectors. Open the \u201cheel_l\u201d Effector node and set the translation to 0, 0, 50. Then compile and observe new Effector location in the viewport: Drag the Skeletal Mesh asset into a level. In the details panel, set the Anim Class to the animation blueprint asset we just created: Now click Play. Observe that the left foot is reaching up, while the right foot remains planted on the ground. The pelvis, being free of any effectors, will automatically translate and rotate to help the feet reach the targets. Congratulations! Power IK is now setup and working. From here, you are ready to drive the positions and rotations of the effectors through blueprint. These transforms can come from any source. Sophisticated procedural animation systems can be built ontop of Power IK. For testing/debug purposes, you can create a PowerIK Interactive Rig which allows you to interactively pull your effector positions with the mouse.","title":"Quick Start"},{"location":"unreal/ground_node/","text":"Grounding Power IK comes with a dedicated Anim Graph node for contouring your creatures to uneven terrain. Video Tutorial The easiest way to learn how to use the Ground Node is to see it in action in our video tutorial . The video tutorial demonstrates the process of adding ground alignment to the Unreal 3rd person Mannequin. How it Works The Power IK Ground node uses the Power IK Solver to generate a new pose given updated foot positions that are on the ground. It helps to understand the basic algorithm for ground alignment: For each Foot: Calculate foot location in world space Cast a ray from this location If ray hits collider: Smoothly move the effector towards hit point Run solver using new effector locations As you can see, because it is based on raycasts, you have to make sure that your collision filtering and level collision is setup to support good ground IK. How to Setup Grounding For a complete overview of the setup process for Power IK Ground Alignment, checkout the video tutorial . Setup a Ground Node Create a Power IK Ground node. Set the name of the Character Root bone on the node. Select the node and open the Details section. Add to the Feet list and set Bone Name to the name of the foot bone. Set the Collision Trace Channel in the Ground Collision settings. At this point, Power IK will stick the feet to the ground, pulling the whole body if necessary by translating the Character Root bone. The following settings can be used to tune the Ground alignment behavior. Many of these settings are identical to the Power IK Solver settings (since the Ground node is just a different wrapper around the core solver). How to Choose a Character Root Bone The Character Root bone is the top-most bone in the skeleton that represents the \"Center of Gravity\" of the body. This is usually located between the legs at the base of the spine. In the Unreal mannequin, this is called the \"Pelvis\". It may also be called \"Hips\", \"Body\", \"COG\" or anything else depending on the rig naming convention. It is crucial that the Character Root bone moves the entire skin when translated. Typically, this is the ONLY bone in the skeleton that does translate. It's position is also important. For good results, it should be located at the base of the spine and have all leg(s), spine(s) and tail(s) as children of it. Usually the Character root bone is not the same as the actual root bone (the top most bone in the hierarchy). If you are unsure which bone to use, open the Skeleton editor and follow the foot bone up the hierarchy until you reach the first bone that contains the spine and the legs. Select it and translate it to make sure that it has the desired behavior of moving the whole character from a location near the center of gravity for the creature. Exclude Bones Some skeletons may have multiple bones at the Character Root level and they may even lie ontop of each other. It is important that no bones between the Character Root and the feet are located directly ontop of each other (in the path of lineage from the feet to the root). If they are, add them to the Excluded Bones list. Also locate any \"twist\" or helper bones that are located in the path from the feet up to the Character Root. If the helper bones are between the leg bones, they must be excluded or else Power IK will treat them as an additional leg bone and bend them! (Optional) Delta Smooth Speed The Ground Node exposes the Delta Smooth Speed of the foot effectors. This value controls how quickly the feet adapt to changing terrain height (measured in cm/s). If you notice the feet gradually sliding towards the ground height, increase this value until it's no longer noticable. Typically values between 100 and 400 cm/s are suitable for this parameter. (Optional) Pull Weight and Pull Factors Setting the Pull Factors in X and Y to zero (the default) prevents the effector from yanking the body around when the feet have to reach up or down a slope. If you set Z to zero as well, it will prevent the solver from pulling the hips of the character to reach for the ground. This could leave your character floating if the ground is far away from the capsule, though typically this never happens. For creatures with many limbs (like spiders), it may actually be nice to have the limbs pulling the body. For bipeds though, it is typically best to turn PullWeight off completely and let the slope alignment settings move the hips for you. Note: If you notice the hips being yanked around by the feet, try adjusting the PullWeight and Pull Factors. Setup a Collision Trace Channel You have to tell PowerIK what surfaces the ground rays should collide with. These settings may be project specific. For default Unreal settings, the following procedure should ensure correct collision filtering for Unreal characters with a capsule: In Unreal go to Edit > Project Settings > Collision Click New Trace Channel Name it IKTrace and set Default Response to Block Open the Preset section of the Collision settings. Double-click Pawn and set IKTrace to Ignore then click Accept. Set the IKTrace to Ignore Character Mesh presets as well. Locate and select the Power IK Solver node and open the Details panel Open the Ground Settings Collision Channel and set it to: IKTrace Note: It may be necessary to also tell the Character capsule to ignore the IKTrace channel Now Tune the Slope Settings Select the solver node and in the details pane find the Ground Slope section. Tune these settings to achieve the desired ground alignment behavior. See the Ground Slope Settings section for details on what each of these parameters do. Interactive Tuning You can adjust the slope settings interactively while playing in editor. Simply open the Animation Blueprint, select your character and adjust the slope settings. You must Compile the animation blueprint between parameter adjustements to see the effect while playing in editor. It can be useful to place a cube underneath your character that you can rotate freely as you tune slope settings interactively. Collision Settings All the Grounding settings are found by selecting the solver node and opening the details panel: Ground Plane Bone : the name of the bone that represents the \u201cground plane\u201d in your animation. Typically this is just the root bone, but you can use a separate bone if you want. The height of the effector relative to this plane is always maintained. So if the animation pulls the characters foot 10cm above the ground plane, then the foot will be 10cm above the ray cast hit location. Collision Channel : this is the level collision channel that the rays are collided against. Make sure that the level is setup with collision on this channel for the character to collide with. Trace Complex: whether to trace against Complex or Simple collision geometry. Complex is usually preferred, though slightly more expensive. Ray Cast Up : the distance in centimeters to cast upwards looking for terrain to stand on. Ray Cast Down : the distance in centimeters to cast downwards looking for terrain to stand on. Slope Settings Vec3 StrideDirection: Normalized vector that describes the direction of travel. This vector points in the forward facing direction of your character and usually remains constant. MaxGroundAngle: Maximum angle relative to gravity vector to apply leaning and stride scaling. Stride Scaling These settings scale the stride of the foot effectors. Essentially making the character take longer or shorter steps. ScaleStride bool: If true, stride of IsGrounded effectors will be scaled in Stride Direction. UphillStrideScale float: Amount to scale stride when going uphill. Range is 0-1. Default 0.4. DownhillStrideScale float: Amount to scale stride when going downhill. Range is 0-1. Default 0.2. SidehillStrideScale float: Amount to scale stride when on a side-hill. Range is 0-1. Default 1.0. SidehillPushOuterFeet float: Amount (in centimeters) to push outside feet outwards on sidehills. Default is 20.0. SidehillPushInnerFeet float: Amount (in centimeters) to push inside feet outwards on sidehills. Default is 10.0. Leaning These settings rotate the spine of the character to lean into or away from a slope. Lean bool: If True, character root bone is rotated in opposite direction of ground normal. UphillLean float: Amount to lean forward when going uphill. Range is 0-1. Default 0.3. DownhillLean float: Amount to lean backward when going downhill. Range is 0-1. Default 0.5. SidehillLean float: Amount to lean sideways into side-hills. Range is 0-1. Default 0.0. Counter Leaning These settings are designed to allow the head of the character to counteract the spine leaning adjustments. This prevents characters from looking straight down when leaning into an up hill, or straight up when leaning back on a downhill. CounterLean bool: If True, will counter lean CounterLeanBone. Usually this is the head. CounterLeanBoneName Name: Name of base of counter lean bone. Usually this is the base Head bone. UphillCounterLean float: Amount to counter lean backward when going uphill. Range is 0-1. Default 0.8. DownhillCounterLean float: Amount to counter lean backward when going downhill. Range is 0-1. Default 1.0. SidehillCounterLean float: Amount to counter lean sideways into side-hills. Range is 0-1. Default 0.0. Root Offset These settings let you offset the position of the root bone above the foot effectors. It's useful to be able to push the root forward/back and up and down in reaction to the slope. MoveRoot bool: If True, character root bone position is gradually pushed vertically and horizontally. UphillVertOffset float: Amount (in centimeters) to push the character root up/down when going UP hill. Default 10.0. UphillHorizOffset float: Amount (in centimeters) to push the character root forward/back when going UP hill. Default -20.0. DownhillVertOffset float: Amount (in centimeters) to push the character root up/down when going DOWN hill. Default 10.0. DownhillHorizOffset float: Amount (in centimeters) to push the character root forward/back when going DOWN hill. Default 20.0. SidehillVertOffset float: Amount (in centimeters) to push the character root up/down when on a SIDE hill. Default -10.0. SidehillHorizOffset float: Amount (in centimeters) to push the character root forward/back when on a SIDE hill. Default -10.0. Foot Rotation It is useful to be able to control the rotation of the foot pitch and roll independently. Creatures usually orient the pitch of their foot to the ground, but only slightly roll the foot to the ground. RotateFootToGround bool: If True, feet are oriented to ground normal. PitchFootAmount float: Amount to pitch foot to orient to up/down hills. Range is 0-1. Default 1.0. RollFootAmount float: Amount to roll foot to orient to sidehills. Range is 0-1. Default 0.6. Foot Offset The Foot Offset feature is useful for nudging feet in the direction of the ground normal so that they come into contact with the ground surface precisely. By default, Power IK maintains the distance of the foot bone relative to the XY plane. Applying an offset may be necessary if the character was not modeled to stand exactly on this plane in the reference pose. Offset Feet Positions bool: If True, feet positions are offset in direction of ground normal. Static Foot Offset float: Amount in centimeters to push feet in direction of ground normal.","title":"Ground Node"},{"location":"unreal/ground_node/#grounding","text":"Power IK comes with a dedicated Anim Graph node for contouring your creatures to uneven terrain.","title":"Grounding"},{"location":"unreal/ground_node/#video-tutorial","text":"The easiest way to learn how to use the Ground Node is to see it in action in our video tutorial . The video tutorial demonstrates the process of adding ground alignment to the Unreal 3rd person Mannequin.","title":"Video Tutorial"},{"location":"unreal/ground_node/#how-it-works","text":"The Power IK Ground node uses the Power IK Solver to generate a new pose given updated foot positions that are on the ground. It helps to understand the basic algorithm for ground alignment: For each Foot: Calculate foot location in world space Cast a ray from this location If ray hits collider: Smoothly move the effector towards hit point Run solver using new effector locations As you can see, because it is based on raycasts, you have to make sure that your collision filtering and level collision is setup to support good ground IK.","title":"How it Works"},{"location":"unreal/ground_node/#how-to-setup-grounding","text":"For a complete overview of the setup process for Power IK Ground Alignment, checkout the video tutorial .","title":"How to Setup Grounding"},{"location":"unreal/ground_node/#setup-a-ground-node","text":"Create a Power IK Ground node. Set the name of the Character Root bone on the node. Select the node and open the Details section. Add to the Feet list and set Bone Name to the name of the foot bone. Set the Collision Trace Channel in the Ground Collision settings. At this point, Power IK will stick the feet to the ground, pulling the whole body if necessary by translating the Character Root bone. The following settings can be used to tune the Ground alignment behavior. Many of these settings are identical to the Power IK Solver settings (since the Ground node is just a different wrapper around the core solver).","title":"Setup a Ground Node"},{"location":"unreal/ground_node/#how-to-choose-a-character-root-bone","text":"The Character Root bone is the top-most bone in the skeleton that represents the \"Center of Gravity\" of the body. This is usually located between the legs at the base of the spine. In the Unreal mannequin, this is called the \"Pelvis\". It may also be called \"Hips\", \"Body\", \"COG\" or anything else depending on the rig naming convention. It is crucial that the Character Root bone moves the entire skin when translated. Typically, this is the ONLY bone in the skeleton that does translate. It's position is also important. For good results, it should be located at the base of the spine and have all leg(s), spine(s) and tail(s) as children of it. Usually the Character root bone is not the same as the actual root bone (the top most bone in the hierarchy). If you are unsure which bone to use, open the Skeleton editor and follow the foot bone up the hierarchy until you reach the first bone that contains the spine and the legs. Select it and translate it to make sure that it has the desired behavior of moving the whole character from a location near the center of gravity for the creature.","title":"How to Choose a Character Root Bone"},{"location":"unreal/ground_node/#exclude-bones","text":"Some skeletons may have multiple bones at the Character Root level and they may even lie ontop of each other. It is important that no bones between the Character Root and the feet are located directly ontop of each other (in the path of lineage from the feet to the root). If they are, add them to the Excluded Bones list. Also locate any \"twist\" or helper bones that are located in the path from the feet up to the Character Root. If the helper bones are between the leg bones, they must be excluded or else Power IK will treat them as an additional leg bone and bend them!","title":"Exclude Bones"},{"location":"unreal/ground_node/#optional-delta-smooth-speed","text":"The Ground Node exposes the Delta Smooth Speed of the foot effectors. This value controls how quickly the feet adapt to changing terrain height (measured in cm/s). If you notice the feet gradually sliding towards the ground height, increase this value until it's no longer noticable. Typically values between 100 and 400 cm/s are suitable for this parameter.","title":"(Optional) Delta Smooth Speed"},{"location":"unreal/ground_node/#optional-pull-weight-and-pull-factors","text":"Setting the Pull Factors in X and Y to zero (the default) prevents the effector from yanking the body around when the feet have to reach up or down a slope. If you set Z to zero as well, it will prevent the solver from pulling the hips of the character to reach for the ground. This could leave your character floating if the ground is far away from the capsule, though typically this never happens. For creatures with many limbs (like spiders), it may actually be nice to have the limbs pulling the body. For bipeds though, it is typically best to turn PullWeight off completely and let the slope alignment settings move the hips for you. Note: If you notice the hips being yanked around by the feet, try adjusting the PullWeight and Pull Factors.","title":"(Optional) Pull Weight and Pull Factors"},{"location":"unreal/ground_node/#setup-a-collision-trace-channel","text":"You have to tell PowerIK what surfaces the ground rays should collide with. These settings may be project specific. For default Unreal settings, the following procedure should ensure correct collision filtering for Unreal characters with a capsule: In Unreal go to Edit > Project Settings > Collision Click New Trace Channel Name it IKTrace and set Default Response to Block Open the Preset section of the Collision settings. Double-click Pawn and set IKTrace to Ignore then click Accept. Set the IKTrace to Ignore Character Mesh presets as well. Locate and select the Power IK Solver node and open the Details panel Open the Ground Settings Collision Channel and set it to: IKTrace Note: It may be necessary to also tell the Character capsule to ignore the IKTrace channel","title":"Setup a Collision Trace Channel"},{"location":"unreal/ground_node/#now-tune-the-slope-settings","text":"Select the solver node and in the details pane find the Ground Slope section. Tune these settings to achieve the desired ground alignment behavior. See the Ground Slope Settings section for details on what each of these parameters do.","title":"Now Tune the Slope Settings"},{"location":"unreal/ground_node/#interactive-tuning","text":"You can adjust the slope settings interactively while playing in editor. Simply open the Animation Blueprint, select your character and adjust the slope settings. You must Compile the animation blueprint between parameter adjustements to see the effect while playing in editor. It can be useful to place a cube underneath your character that you can rotate freely as you tune slope settings interactively.","title":"Interactive Tuning"},{"location":"unreal/ground_node/#collision-settings","text":"All the Grounding settings are found by selecting the solver node and opening the details panel: Ground Plane Bone : the name of the bone that represents the \u201cground plane\u201d in your animation. Typically this is just the root bone, but you can use a separate bone if you want. The height of the effector relative to this plane is always maintained. So if the animation pulls the characters foot 10cm above the ground plane, then the foot will be 10cm above the ray cast hit location. Collision Channel : this is the level collision channel that the rays are collided against. Make sure that the level is setup with collision on this channel for the character to collide with. Trace Complex: whether to trace against Complex or Simple collision geometry. Complex is usually preferred, though slightly more expensive. Ray Cast Up : the distance in centimeters to cast upwards looking for terrain to stand on. Ray Cast Down : the distance in centimeters to cast downwards looking for terrain to stand on.","title":"Collision Settings"},{"location":"unreal/ground_node/#slope-settings","text":"Vec3 StrideDirection: Normalized vector that describes the direction of travel. This vector points in the forward facing direction of your character and usually remains constant. MaxGroundAngle: Maximum angle relative to gravity vector to apply leaning and stride scaling.","title":"Slope Settings"},{"location":"unreal/ground_node/#stride-scaling","text":"These settings scale the stride of the foot effectors. Essentially making the character take longer or shorter steps. ScaleStride bool: If true, stride of IsGrounded effectors will be scaled in Stride Direction. UphillStrideScale float: Amount to scale stride when going uphill. Range is 0-1. Default 0.4. DownhillStrideScale float: Amount to scale stride when going downhill. Range is 0-1. Default 0.2. SidehillStrideScale float: Amount to scale stride when on a side-hill. Range is 0-1. Default 1.0. SidehillPushOuterFeet float: Amount (in centimeters) to push outside feet outwards on sidehills. Default is 20.0. SidehillPushInnerFeet float: Amount (in centimeters) to push inside feet outwards on sidehills. Default is 10.0.","title":"Stride Scaling"},{"location":"unreal/ground_node/#leaning","text":"These settings rotate the spine of the character to lean into or away from a slope. Lean bool: If True, character root bone is rotated in opposite direction of ground normal. UphillLean float: Amount to lean forward when going uphill. Range is 0-1. Default 0.3. DownhillLean float: Amount to lean backward when going downhill. Range is 0-1. Default 0.5. SidehillLean float: Amount to lean sideways into side-hills. Range is 0-1. Default 0.0.","title":"Leaning"},{"location":"unreal/ground_node/#counter-leaning","text":"These settings are designed to allow the head of the character to counteract the spine leaning adjustments. This prevents characters from looking straight down when leaning into an up hill, or straight up when leaning back on a downhill. CounterLean bool: If True, will counter lean CounterLeanBone. Usually this is the head. CounterLeanBoneName Name: Name of base of counter lean bone. Usually this is the base Head bone. UphillCounterLean float: Amount to counter lean backward when going uphill. Range is 0-1. Default 0.8. DownhillCounterLean float: Amount to counter lean backward when going downhill. Range is 0-1. Default 1.0. SidehillCounterLean float: Amount to counter lean sideways into side-hills. Range is 0-1. Default 0.0.","title":"Counter Leaning"},{"location":"unreal/ground_node/#root-offset","text":"These settings let you offset the position of the root bone above the foot effectors. It's useful to be able to push the root forward/back and up and down in reaction to the slope. MoveRoot bool: If True, character root bone position is gradually pushed vertically and horizontally. UphillVertOffset float: Amount (in centimeters) to push the character root up/down when going UP hill. Default 10.0. UphillHorizOffset float: Amount (in centimeters) to push the character root forward/back when going UP hill. Default -20.0. DownhillVertOffset float: Amount (in centimeters) to push the character root up/down when going DOWN hill. Default 10.0. DownhillHorizOffset float: Amount (in centimeters) to push the character root forward/back when going DOWN hill. Default 20.0. SidehillVertOffset float: Amount (in centimeters) to push the character root up/down when on a SIDE hill. Default -10.0. SidehillHorizOffset float: Amount (in centimeters) to push the character root forward/back when on a SIDE hill. Default -10.0.","title":"Root Offset"},{"location":"unreal/ground_node/#foot-rotation","text":"It is useful to be able to control the rotation of the foot pitch and roll independently. Creatures usually orient the pitch of their foot to the ground, but only slightly roll the foot to the ground. RotateFootToGround bool: If True, feet are oriented to ground normal. PitchFootAmount float: Amount to pitch foot to orient to up/down hills. Range is 0-1. Default 1.0. RollFootAmount float: Amount to roll foot to orient to sidehills. Range is 0-1. Default 0.6.","title":"Foot Rotation"},{"location":"unreal/ground_node/#foot-offset","text":"The Foot Offset feature is useful for nudging feet in the direction of the ground normal so that they come into contact with the ground surface precisely. By default, Power IK maintains the distance of the foot bone relative to the XY plane. Applying an offset may be necessary if the character was not modeled to stand exactly on this plane in the reference pose. Offset Feet Positions bool: If True, feet positions are offset in direction of ground normal. Static Foot Offset float: Amount in centimeters to push feet in direction of ground normal.","title":"Foot Offset"},{"location":"unreal/inertia/","text":"Body Inertia Without any inertia, the body of a skeleton will react immediately to the motion of the effectors. If the effectors are controlling extremeties (like feet and hands) it may be desirable to delay the effect of their motion on the body to give it a better sense of weight. Smoothing the body motion approximates the tendency of creatures to spare energy by not moving their core mass any more than is necesssary. Inertia is a feature available on all Power IK nodes. Smooth Damping Based Inertia This is the most typical (default) type of inertia. This delays the body's reaction to the motion of the effectors. This effect will not \"wobble\" and overshoot. It simply \"catches up\" to the effector motion in a gradual, dampened and non-linear way. To enable \"Smooth\" inertia: Find the \"Body Inertia\" section of the Solver settings. Set \"Apply Inertia To Body\" to true. Tune the Smooth Factor value. Smooth Factor : The Smooth Factor determines how much the body motion is smoothed when the effectors positions are modified. Typical values range from 1 to 20, which higher numbers smoothing the motion more and causing a longer delay between the effector motion and the body's reaction. Spring Based Inertia The Smooth Factor has a few desirable properties. It is unconditionally stable and will not \"overshoot\" the target body location. In some cases though, it may be desirable to give the body a \"springy\" behavior. This can be achieved by: Find the \"Body Inertia\" section of the Solver settings. Set \"Apply Inertia To Body\" to true. Set \"Use Spring\" to true. Tune \"Spring Strength\" and \"Spring Damping\" as described below. Spring Strength : Typical values range from 10 to 300. Determines how quickly the body is pulled towards the effectors when they are moved. Spring Damping : Typical values range from 0.01 to 0.5. Dampens the spring motion. Higher values cause the spring motion to settle sooner.","title":"Body Inertia"},{"location":"unreal/inertia/#body-inertia","text":"Without any inertia, the body of a skeleton will react immediately to the motion of the effectors. If the effectors are controlling extremeties (like feet and hands) it may be desirable to delay the effect of their motion on the body to give it a better sense of weight. Smoothing the body motion approximates the tendency of creatures to spare energy by not moving their core mass any more than is necesssary. Inertia is a feature available on all Power IK nodes.","title":"Body Inertia"},{"location":"unreal/inertia/#smooth-damping-based-inertia","text":"This is the most typical (default) type of inertia. This delays the body's reaction to the motion of the effectors. This effect will not \"wobble\" and overshoot. It simply \"catches up\" to the effector motion in a gradual, dampened and non-linear way. To enable \"Smooth\" inertia: Find the \"Body Inertia\" section of the Solver settings. Set \"Apply Inertia To Body\" to true. Tune the Smooth Factor value. Smooth Factor : The Smooth Factor determines how much the body motion is smoothed when the effectors positions are modified. Typical values range from 1 to 20, which higher numbers smoothing the motion more and causing a longer delay between the effector motion and the body's reaction.","title":"Smooth Damping Based Inertia"},{"location":"unreal/inertia/#spring-based-inertia","text":"The Smooth Factor has a few desirable properties. It is unconditionally stable and will not \"overshoot\" the target body location. In some cases though, it may be desirable to give the body a \"springy\" behavior. This can be achieved by: Find the \"Body Inertia\" section of the Solver settings. Set \"Apply Inertia To Body\" to true. Set \"Use Spring\" to true. Tune \"Spring Strength\" and \"Spring Damping\" as described below. Spring Strength : Typical values range from 10 to 300. Determines how quickly the body is pulled towards the effectors when they are moved. Spring Damping : Typical values range from 0.01 to 0.5. Dampens the spring motion. Higher values cause the spring motion to settle sooner.","title":"Spring Based Inertia"},{"location":"unreal/limits/","text":"Limits and Stiffness It is desireable to have control over how much bones in your skeleton can rotate in any given direction. This is an active area of development in Power IK. Joint Limits Note: Angular joint limits are currently in active development and are not yet supported in Power IK. Until joint limits are released, you can achieve a similar result using Bend Directions , which are currently supported. Joint Stiffness Note: Joint stiffness is currently in active development and is experimental. As of v1.3, Power IK adds basic support for joint stiffness. The feature is being actively developed and may node provide expected results in all cases yet.","title":"Limits and Stiffness"},{"location":"unreal/limits/#limits-and-stiffness","text":"It is desireable to have control over how much bones in your skeleton can rotate in any given direction. This is an active area of development in Power IK.","title":"Limits and Stiffness"},{"location":"unreal/limits/#joint-limits","text":"Note: Angular joint limits are currently in active development and are not yet supported in Power IK. Until joint limits are released, you can achieve a similar result using Bend Directions , which are currently supported.","title":"Joint Limits"},{"location":"unreal/limits/#joint-stiffness","text":"Note: Joint stiffness is currently in active development and is experimental. As of v1.3, Power IK adds basic support for joint stiffness. The feature is being actively developed and may node provide expected results in all cases yet.","title":"Joint Stiffness"},{"location":"unreal/old_versions/","text":"Compiling Power IK for Old Unreal Versions The Power IK Unreal Plugin is currently only maintained on the latest version of Unreal (4.25 at time of writing). But it should be compatible with older versions of Unreal with minimal modifications. Compile for Older Unreal Versions To use PowerIK with an older version of Unreal, you need to add it to your project and recompile the plugin as part of your project. Remove Engine Installation First remove any Engine installations of PowerIK before proceeding. Simply delete the PowerIK folder located in your engine plugins folder: C:\\Program Files\\Epic Games\\UE_4.xx\\Engine\\Plugins Install in Project and Compile Open your project and enable the Control Rig plugin. Save and close the project. Add the \"PowerIK\" plugin folder to YourProject/Plugins/ Very the location of the .uplugin file is YourProject/Plugins/PowerIK/PowerIK.uplugin Right click on YourProject.uproject and select Generate Visual Studio project files Open YourProject.sln Locate and open PowerIK.uplugin in the Solution Explorer Set the EngineVersion to \"4.XX.X\" (replacing X with your version) Build the solution and verify that PowerIK is working in your project. NOTE: This process has been tested with 4.23 and 4.24. Older versions of Unreal may introduce minor changes in API that may require more work. NOTE: You must have the Control Rig plugin enabled in your project or you will get compiler errors about missing \"RigUnit\" header files.","title":"Compiling for Old Unreal"},{"location":"unreal/old_versions/#compiling-power-ik-for-old-unreal-versions","text":"The Power IK Unreal Plugin is currently only maintained on the latest version of Unreal (4.25 at time of writing). But it should be compatible with older versions of Unreal with minimal modifications.","title":"Compiling Power IK for Old Unreal Versions"},{"location":"unreal/old_versions/#compile-for-older-unreal-versions","text":"To use PowerIK with an older version of Unreal, you need to add it to your project and recompile the plugin as part of your project.","title":"Compile for Older Unreal Versions"},{"location":"unreal/old_versions/#remove-engine-installation","text":"First remove any Engine installations of PowerIK before proceeding. Simply delete the PowerIK folder located in your engine plugins folder: C:\\Program Files\\Epic Games\\UE_4.xx\\Engine\\Plugins","title":"Remove Engine Installation"},{"location":"unreal/old_versions/#install-in-project-and-compile","text":"Open your project and enable the Control Rig plugin. Save and close the project. Add the \"PowerIK\" plugin folder to YourProject/Plugins/ Very the location of the .uplugin file is YourProject/Plugins/PowerIK/PowerIK.uplugin Right click on YourProject.uproject and select Generate Visual Studio project files Open YourProject.sln Locate and open PowerIK.uplugin in the Solution Explorer Set the EngineVersion to \"4.XX.X\" (replacing X with your version) Build the solution and verify that PowerIK is working in your project. NOTE: This process has been tested with 4.23 and 4.24. Older versions of Unreal may introduce minor changes in API that may require more work. NOTE: You must have the Control Rig plugin enabled in your project or you will get compiler errors about missing \"RigUnit\" header files.","title":"Install in Project and Compile"},{"location":"unreal/packaging/","text":"Packaging Your Game Windows In Windows, the Power IK Unreal plugin registers a .dll (POWERIK.dll) with Unreal\u2019s build system that is automatically copied into the build folder when packaging Win64 builds. This .dll must be distributed with the final .exe. You should not have to manage this yourself, just be aware that it is required. Linux As of v1.46, the Power IK binary distribution comes with precompiled static libaries for packaging Linux builds with Unreal. Linux builds will statically compile Power IK into your executable. Dynamic linking is not provided for Linux. Other Platforms Power IK is available for all major platforms. Please contact us if you would like to license Power IK for consoles or other platforms.","title":"Packaging"},{"location":"unreal/packaging/#packaging-your-game","text":"","title":"Packaging Your Game"},{"location":"unreal/packaging/#windows","text":"In Windows, the Power IK Unreal plugin registers a .dll (POWERIK.dll) with Unreal\u2019s build system that is automatically copied into the build folder when packaging Win64 builds. This .dll must be distributed with the final .exe. You should not have to manage this yourself, just be aware that it is required.","title":"Windows"},{"location":"unreal/packaging/#linux","text":"As of v1.46, the Power IK binary distribution comes with precompiled static libaries for packaging Linux builds with Unreal. Linux builds will statically compile Power IK into your executable. Dynamic linking is not provided for Linux.","title":"Linux"},{"location":"unreal/packaging/#other-platforms","text":"Power IK is available for all major platforms. Please contact us if you would like to license Power IK for consoles or other platforms.","title":"Other Platforms"},{"location":"unreal/root_rotation/","text":"Root Rotation Multiplier The Power IK solver has an attribute called Root Rotation Multiplier . The default value is 1.0 which causes the root bone to rotate a small amount in reaction to the movement of the effectors. In some cases, it may be preferrable to add more or less rotation on the root bone. For human characters, the pelvis can be quite loose and a value of 3.0 or more may be needed to get natural pelvis rotation when the feet and torso are being pulled.","title":"Root Rotation"},{"location":"unreal/root_rotation/#root-rotation-multiplier","text":"The Power IK solver has an attribute called Root Rotation Multiplier . The default value is 1.0 which causes the root bone to rotate a small amount in reaction to the movement of the effectors. In some cases, it may be preferrable to add more or less rotation on the root bone. For human characters, the pelvis can be quite loose and a value of 3.0 or more may be needed to get natural pelvis rotation when the feet and torso are being pulled.","title":"Root Rotation Multiplier"},{"location":"unreal/solver_bones/","text":"Solver Bones The Power IK solver needs some information about each skeleton. Note: Power IK does not support changing these bone names at run-time. They must be set prior to the first call to Solve(). Character Root Set the Character Root to the top-most joint that is part of your character's body. This is usually not the actual top-node of the skeleton. This defaults to \"pelvis\" though some rigs call it \"hips\" or \"body\". Any bones below the Character Root will potentially be affected by Power IK. Any bones above the Character Root are completely ignored by Power IK and will pass through the solver unaffected. Excluded Bones This is an important feature for getting good results from Power IK. In the Constraints section of the solver details panel you will find a list of Names called Excluded Bones . Use this list to specify those bones that should not bend or be considered as part of the IK solve. Bones in this list will be completely ignored by Power IK. There is no additional cost for excluding bones. Which Bones Are Solved It is important to understand how Power IK determines which bones will be affected by the solver, as this will help you determine which bones ought to be excluded for best results. When the solver is initialized, it walks UP the hierarchy (child to parent) from each effector until it reaches the Character Root bone. All of the bones along this path will be solved for. All the extra bones (ie those bones not in this direct lineage), are simply parented into the solved sub-skeleton. There is no point excluding a Bone that is not a direct ancestor of an effector. Power IK takes care of these for you. What Bones to Exclude You should exclude Bones in the following circumstances: The bone is organizational . It acts as a grouping or a dummy transform for it's children, but does not have any anatomical purpose. Bones like this can often negatively impact the quality of the solved pose. The bone is for twisting deformation . So called \"twist bones\" are often inserted into a hiearchy for purposes of avoiding the candy-wrapper skinning artifact. Such bones are not meant to be bent and thus need to be excluded. The bone is coincident with another bone . If a child bone lies directly on top of it's parent, this can make it difficult for the solver to reconcile it's orientation. Exclude coincident bones to avoid this issue.","title":"Solver Bones"},{"location":"unreal/solver_bones/#solver-bones","text":"The Power IK solver needs some information about each skeleton. Note: Power IK does not support changing these bone names at run-time. They must be set prior to the first call to Solve().","title":"Solver Bones"},{"location":"unreal/solver_bones/#character-root","text":"Set the Character Root to the top-most joint that is part of your character's body. This is usually not the actual top-node of the skeleton. This defaults to \"pelvis\" though some rigs call it \"hips\" or \"body\". Any bones below the Character Root will potentially be affected by Power IK. Any bones above the Character Root are completely ignored by Power IK and will pass through the solver unaffected.","title":"Character Root"},{"location":"unreal/solver_bones/#excluded-bones","text":"This is an important feature for getting good results from Power IK. In the Constraints section of the solver details panel you will find a list of Names called Excluded Bones . Use this list to specify those bones that should not bend or be considered as part of the IK solve. Bones in this list will be completely ignored by Power IK. There is no additional cost for excluding bones.","title":"Excluded Bones"},{"location":"unreal/solver_bones/#which-bones-are-solved","text":"It is important to understand how Power IK determines which bones will be affected by the solver, as this will help you determine which bones ought to be excluded for best results. When the solver is initialized, it walks UP the hierarchy (child to parent) from each effector until it reaches the Character Root bone. All of the bones along this path will be solved for. All the extra bones (ie those bones not in this direct lineage), are simply parented into the solved sub-skeleton. There is no point excluding a Bone that is not a direct ancestor of an effector. Power IK takes care of these for you.","title":"Which Bones Are Solved"},{"location":"unreal/solver_bones/#what-bones-to-exclude","text":"You should exclude Bones in the following circumstances: The bone is organizational . It acts as a grouping or a dummy transform for it's children, but does not have any anatomical purpose. Bones like this can often negatively impact the quality of the solved pose. The bone is for twisting deformation . So called \"twist bones\" are often inserted into a hiearchy for purposes of avoiding the candy-wrapper skinning artifact. Such bones are not meant to be bent and thus need to be excluded. The bone is coincident with another bone . If a child bone lies directly on top of it's parent, this can make it difficult for the solver to reconcile it's orientation. Exclude coincident bones to avoid this issue.","title":"What Bones to Exclude"},{"location":"unreal/solver_performance/","text":"Solver Performance Power IK uses a proprietary iterative solver that can generate nice looking poses with remarkably few iterations compared to standard IK solutions. That said, you should be aware of the performance implications of using Power IK. Especially on resource constrained devices like mobile CPUs. Iterations The primary means of controlling the cost of Power IK is to adjust the number of Squash and Stretch iterations. Both default to 6 iterations each. It is unlikely that you will need more iterations than this. Though depending on the complexity of your skeleton, you may be able to get away with less. Max Squash Iterations : This is the number of iterations that the solver computes when squashing a limb. Typically, this can be left at the default. Though higher iterations may help with long complex limbs that have many bones . Max Stretch Iterations : Set this as low as you can before your effectors stop reaching their targets, or if your chain forms kinks or wobbles. A value of 6 is typically good enough even for complex chains. Note: these settings can affect performance. You should always reduce the iterations as much as you can while maintaining good results. Solver Alpha Power IK can be smoothly blended on/off with the Solver Alpha input. This value ranges from 0-1. At zero, Power IK will shut off completely . So this can be used as a simple way of disabling the solver completely. Values in-between 0 and 1 will smoothly blend the skeleton from the input pose to the results of the solver. Note: The Solver Alpha value is more efficient than the built in Alpha value that all Unreal AnimGraph nodes provide. The default Alpha value blends the resulting pose on each bone. Whereas the Solver Alpha value blends only the effectors values in the solver itself; saving the cost of blending on all the bones. Level of Detail The effect of Power IK on your skeletons may not be visible at a distance. Therefore it is wise blend the effect off when the distance to the skeleton exceeds your LOD threshold. This allows you to only pay the cost of Power IK where it matters most. Every game engine and software has it's own requirements for determining when and how to switch between levels of detail. Power IK merely provides the hooks to blend itself off, using the Solver Alpha value. It's up to you to determine when to do that. Note: If desired, you could also dynamically adjust the solver iterations based on the LOD. Power IK supports dynamically adjusting iterations. Profiling Power IK Power IK's core algorithms are very efficient and getting faster with each release. But regardless, it\u2019s always important to understand exactly what it costs to run. While playing a development build or with Play in Editor, you can execute the command: stat anim This will bring up a detailed breakdown of the animation performance in any given scenario. Power IK adds two entries into this list, Power IK Total and Power IK Solve .","title":"Solver Performance"},{"location":"unreal/solver_performance/#solver-performance","text":"Power IK uses a proprietary iterative solver that can generate nice looking poses with remarkably few iterations compared to standard IK solutions. That said, you should be aware of the performance implications of using Power IK. Especially on resource constrained devices like mobile CPUs.","title":"Solver Performance"},{"location":"unreal/solver_performance/#iterations","text":"The primary means of controlling the cost of Power IK is to adjust the number of Squash and Stretch iterations. Both default to 6 iterations each. It is unlikely that you will need more iterations than this. Though depending on the complexity of your skeleton, you may be able to get away with less. Max Squash Iterations : This is the number of iterations that the solver computes when squashing a limb. Typically, this can be left at the default. Though higher iterations may help with long complex limbs that have many bones . Max Stretch Iterations : Set this as low as you can before your effectors stop reaching their targets, or if your chain forms kinks or wobbles. A value of 6 is typically good enough even for complex chains. Note: these settings can affect performance. You should always reduce the iterations as much as you can while maintaining good results.","title":"Iterations"},{"location":"unreal/solver_performance/#solver-alpha","text":"Power IK can be smoothly blended on/off with the Solver Alpha input. This value ranges from 0-1. At zero, Power IK will shut off completely . So this can be used as a simple way of disabling the solver completely. Values in-between 0 and 1 will smoothly blend the skeleton from the input pose to the results of the solver. Note: The Solver Alpha value is more efficient than the built in Alpha value that all Unreal AnimGraph nodes provide. The default Alpha value blends the resulting pose on each bone. Whereas the Solver Alpha value blends only the effectors values in the solver itself; saving the cost of blending on all the bones.","title":"Solver Alpha"},{"location":"unreal/solver_performance/#level-of-detail","text":"The effect of Power IK on your skeletons may not be visible at a distance. Therefore it is wise blend the effect off when the distance to the skeleton exceeds your LOD threshold. This allows you to only pay the cost of Power IK where it matters most. Every game engine and software has it's own requirements for determining when and how to switch between levels of detail. Power IK merely provides the hooks to blend itself off, using the Solver Alpha value. It's up to you to determine when to do that. Note: If desired, you could also dynamically adjust the solver iterations based on the LOD. Power IK supports dynamically adjusting iterations.","title":"Level of Detail"},{"location":"unreal/solver_performance/#profiling-power-ik","text":"Power IK's core algorithms are very efficient and getting faster with each release. But regardless, it\u2019s always important to understand exactly what it costs to run. While playing a development build or with Play in Editor, you can execute the command: stat anim This will bring up a detailed breakdown of the animation performance in any given scenario. Power IK adds two entries into this list, Power IK Total and Power IK Solve .","title":"Profiling Power IK"},{"location":"unreal/solver_setup/","text":"Power IK Solver Node What Is a Power IK Solver? The core of the plugin is the Power IK solver Animation Graph node. It takes an input pose and a list of effectors . The effectors come with target transforms corresponding to joints in the skeleton. Translating or rotating an effector pulls the affected joint, with its surrounding skeleton, towards the effector transform. The solver calculates the pose to reach the affected bones towards the new set of locations. Basic Solver Setup Right-click in your animation graph and create a Power IK Solver node. Set the name of the Character Root and Ground Plane Bone. See the Bone Name Settings for explanations of these fields. In the details panel, click the \u201c+\u201d icon to add as many effectors as you need. Right-click on the Power IK Solver and click Refresh Node to make the effector pins visible in the graph. Drag off the pins to create Power IK Effector nodes. Set the Bone name of the effectors. Typically these are foot joints, but they can be any bone in the body. Connect the input pose and the output pose to the solver node. Compile the animation blueprint. Select the solver node. If everything is setup correctly, you should see yellow diamonds where your effectors are located. From here you are ready to drive the effector positions and rotations to pull the skeleton as desired. See the section on Power IK Effectors for more info. Note on Blueprint Preview Window The Power IK solver node will not affect your skeleton in the animation blueprint preview window. Typically, the effector inputs require runtime information. So the solver evaluates only while playing in editor, or in a final build.","title":"Solver Setup"},{"location":"unreal/solver_setup/#power-ik-solver-node","text":"","title":"Power IK Solver Node"},{"location":"unreal/solver_setup/#what-is-a-power-ik-solver","text":"The core of the plugin is the Power IK solver Animation Graph node. It takes an input pose and a list of effectors . The effectors come with target transforms corresponding to joints in the skeleton. Translating or rotating an effector pulls the affected joint, with its surrounding skeleton, towards the effector transform. The solver calculates the pose to reach the affected bones towards the new set of locations.","title":"What Is a Power IK Solver?"},{"location":"unreal/solver_setup/#basic-solver-setup","text":"Right-click in your animation graph and create a Power IK Solver node. Set the name of the Character Root and Ground Plane Bone. See the Bone Name Settings for explanations of these fields. In the details panel, click the \u201c+\u201d icon to add as many effectors as you need. Right-click on the Power IK Solver and click Refresh Node to make the effector pins visible in the graph. Drag off the pins to create Power IK Effector nodes. Set the Bone name of the effectors. Typically these are foot joints, but they can be any bone in the body. Connect the input pose and the output pose to the solver node. Compile the animation blueprint. Select the solver node. If everything is setup correctly, you should see yellow diamonds where your effectors are located. From here you are ready to drive the effector positions and rotations to pull the skeleton as desired. See the section on Power IK Effectors for more info.","title":"Basic Solver Setup"},{"location":"unreal/solver_setup/#note-on-blueprint-preview-window","text":"The Power IK solver node will not affect your skeleton in the animation blueprint preview window. Typically, the effector inputs require runtime information. So the solver evaluates only while playing in editor, or in a final build.","title":"Note on Blueprint Preview Window"},{"location":"unreal/walk_blueprint/","text":"ATTENTION!! For actual Procedural Walking Animation, please use the included Anim Graph Walk Node. It is a production ready system that is much easier to setup. These blueprints are included as bonus examples of how you can drive a Power IK solver using your own Blueprint systems. Bonus Procedural Animation Blueprint Power IK is a generic tool that can be used for a multitude of purposes. We included a bonus set of blueprints to get you started generating procedural animation with Power IK. What is Procedural Animation Procedural animation simply means, \u201canything that isn\u2019t pre-recorded keyframes\u201d. This includes physics, IK and direct bone manipulation. Often these methods are mixed with keyframe animation to achieve dynamic and compelling behaviors that would otherwise be impossible using keyframes alone. Procedural animation is gaining in popularity and it greatly benefits from a full body IK solver. Typical methods attempt to algorithmically generate foot positions, or some high-level goal for the animation, and let IK and physics create the final pose. Using a regular single-chain IK solver, it is difficult to get the full pose to look realistic. Limbs can feel disconnected from each other and the rest of the body (because they are). That\u2019s where a full-body solver like Power IK can help you achieve more natural poses with less effort. With Power IK, you can set foot positions procedurally, and let the solver create a natural pose for the rest of the body. Actor Setup Inside Content/Bonus_ProceduralAnim you will find two blueprints, BP_Leg and BP_LegManager. These blueprints exist solely to generate foot positions which are then fed into Power IK. Add the Legs and Leg Manager to an actor: Add a BP_LegManager actor component to an actor. Add a BP_Leg for each leg of the actor. Position the scene component in the viewport at the location of the hips. Orient the BP_Leg scene component in the actor Viewport so that +X points in the direction you want to ray-cast for foot positions. Set a tag on each BP_Leg component so you can identify it later. Animation Blueprint Setup Now you need to get the foot positions from the BP_Leg components and feed them into Power IK in the animation graph. Get references to the actor components in the animation blueprint: Create 3 variables in the animation blueprint. One BP_LegManager object reference, and two BP_Leg references (or however many legs you have). On Begin Play, we need to get a reference to the Leg Manager component and store it. And do the same for the legs using the included Get Leg Reference function and the tag names that you added to each BP_Leg component. Add two vector-type variables to store the foot positions, and get them from the legs using the Blueprint Update Animation event. Drag these foot position vectors into the animation graph and connect them to the Position of a PowerIK Effector. Set the effector space to World Space. And plug it into a solver. You will of course need your character capsule to actually move if you hope to see the legs walking. The included project has a sample of a random patrol behavior tree which is enough to test procedural walking. See the Dino_Walking sample blueprints for detailed comments on what exactly the BP_Leg and BP_LegManager are doing to generate foot positions procedurally. Tune the Walking Behavior Different sized characters will take larger or smaller steps at different speeds. Or you may want to even modulate a characters walking behavior depending on their state. Each BP_Leg has a Walking Leg settings category with options for adjusting all aspects of the gait behavior: Ray Cast Length : the distance from the BP_Leg scene component that the system will ray-cast to look for a target foot position. Increase this for larger characters to ensure they can reach the ground. Step Height : the maximum height in centimeters the foot is raised off the ground mid-stride. Step Time : the time in seconds it takes to make a step (from unplanting to replanting). Step Distance : the distance in centimeters to step between unplanting and replanting. The Replant Speed Curve and Replant Height Curves can be modified to adjust the ease-in and ease-out of the foot position and height. The curve ranges are normalized from 0 to 1 which represents the time for a complete step (unplant to replant). Get Creative! The procedural walking blueprints are just a small sample of what\u2019s possible with procedural animation when combined with a full-body IK solver like Power IK. Add More Legs : You could extend the BP_LegManager to support multiple sets of legs, where each set of legs is synchronized. This would open it up to support insects and arachnid gaits. Support Running : You could add support for procedural running by creating a mode that allows feet to unplant at the same time, within \u2018tolerance\u2019 ranges. Layer on Physics and Animation : Layer your procedural walking with procedural look-ats, secondary physics and keyframe animation to add believability and style. More Procedural Actions : You could add procedural turn on spot, jumping and even attacks. Power IK unleashes a lot of possibilities for creative expression with Unreal blueprint.","title":"Walk Blueprint"},{"location":"unreal/walk_blueprint/#bonus-procedural-animation-blueprint","text":"Power IK is a generic tool that can be used for a multitude of purposes. We included a bonus set of blueprints to get you started generating procedural animation with Power IK.","title":"Bonus Procedural Animation Blueprint"},{"location":"unreal/walk_blueprint/#what-is-procedural-animation","text":"Procedural animation simply means, \u201canything that isn\u2019t pre-recorded keyframes\u201d. This includes physics, IK and direct bone manipulation. Often these methods are mixed with keyframe animation to achieve dynamic and compelling behaviors that would otherwise be impossible using keyframes alone. Procedural animation is gaining in popularity and it greatly benefits from a full body IK solver. Typical methods attempt to algorithmically generate foot positions, or some high-level goal for the animation, and let IK and physics create the final pose. Using a regular single-chain IK solver, it is difficult to get the full pose to look realistic. Limbs can feel disconnected from each other and the rest of the body (because they are). That\u2019s where a full-body solver like Power IK can help you achieve more natural poses with less effort. With Power IK, you can set foot positions procedurally, and let the solver create a natural pose for the rest of the body.","title":"What is Procedural Animation"},{"location":"unreal/walk_blueprint/#actor-setup","text":"Inside Content/Bonus_ProceduralAnim you will find two blueprints, BP_Leg and BP_LegManager. These blueprints exist solely to generate foot positions which are then fed into Power IK. Add the Legs and Leg Manager to an actor: Add a BP_LegManager actor component to an actor. Add a BP_Leg for each leg of the actor. Position the scene component in the viewport at the location of the hips. Orient the BP_Leg scene component in the actor Viewport so that +X points in the direction you want to ray-cast for foot positions. Set a tag on each BP_Leg component so you can identify it later.","title":"Actor Setup"},{"location":"unreal/walk_blueprint/#animation-blueprint-setup","text":"Now you need to get the foot positions from the BP_Leg components and feed them into Power IK in the animation graph. Get references to the actor components in the animation blueprint: Create 3 variables in the animation blueprint. One BP_LegManager object reference, and two BP_Leg references (or however many legs you have). On Begin Play, we need to get a reference to the Leg Manager component and store it. And do the same for the legs using the included Get Leg Reference function and the tag names that you added to each BP_Leg component. Add two vector-type variables to store the foot positions, and get them from the legs using the Blueprint Update Animation event. Drag these foot position vectors into the animation graph and connect them to the Position of a PowerIK Effector. Set the effector space to World Space. And plug it into a solver. You will of course need your character capsule to actually move if you hope to see the legs walking. The included project has a sample of a random patrol behavior tree which is enough to test procedural walking. See the Dino_Walking sample blueprints for detailed comments on what exactly the BP_Leg and BP_LegManager are doing to generate foot positions procedurally.","title":"Animation Blueprint Setup"},{"location":"unreal/walk_blueprint/#tune-the-walking-behavior","text":"Different sized characters will take larger or smaller steps at different speeds. Or you may want to even modulate a characters walking behavior depending on their state. Each BP_Leg has a Walking Leg settings category with options for adjusting all aspects of the gait behavior: Ray Cast Length : the distance from the BP_Leg scene component that the system will ray-cast to look for a target foot position. Increase this for larger characters to ensure they can reach the ground. Step Height : the maximum height in centimeters the foot is raised off the ground mid-stride. Step Time : the time in seconds it takes to make a step (from unplanting to replanting). Step Distance : the distance in centimeters to step between unplanting and replanting. The Replant Speed Curve and Replant Height Curves can be modified to adjust the ease-in and ease-out of the foot position and height. The curve ranges are normalized from 0 to 1 which represents the time for a complete step (unplant to replant).","title":"Tune the Walking Behavior"},{"location":"unreal/walk_blueprint/#get-creative","text":"The procedural walking blueprints are just a small sample of what\u2019s possible with procedural animation when combined with a full-body IK solver like Power IK. Add More Legs : You could extend the BP_LegManager to support multiple sets of legs, where each set of legs is synchronized. This would open it up to support insects and arachnid gaits. Support Running : You could add support for procedural running by creating a mode that allows feet to unplant at the same time, within \u2018tolerance\u2019 ranges. Layer on Physics and Animation : Layer your procedural walking with procedural look-ats, secondary physics and keyframe animation to add believability and style. More Procedural Actions : You could add procedural turn on spot, jumping and even attacks. Power IK unleashes a lot of possibilities for creative expression with Unreal blueprint.","title":"Get Creative!"},{"location":"unreal/walk_node/","text":"Walk Node Power IK comes with a dedicated Anim Graph node for procedurally generating walking animation. Experimental / Beta: This node is under active development. Future versions will support fully parameterized style adjustment for hip sway, tilt, bobbing, leaning, arm sway, running and more. But even in it's current form, we expect many users will find it useful. How it Works It helps to understand how the Walk node works. The Walk node requires and responds to root motion. When an Actor containing a Skeletal Mesh running a Walk anim graph node is moved in world space, the Walk node responds to the motion by planting and unplanting the feet in a stepping behavior. Where to place the feet for the next step is determined by raycasting from the Actor's current world space location and rotation. So the Walk node requires a custom trace channel and sufficient world collision. Additionally, if the Actor is not rotated to face the movement direction, the Walk node will generate \"strafing\" type locomotion. The Walk node does not care about the source of the movement and works equally well if it is from AI navigation, a player controlled Pawn class, or even by manually translating or rotating the Actor with the mouse in the editor. Setup a Walk Node In the Animation Graph, create a Power IK Walk node Connect the Output Pose of the Power IK Walk node Set the Character Root bone (see Ground Node docs for a description of how to choose a Character Root) In the Details section of the Walk node, click the + icon next to the Limbs array to add each foot. Set the Start Bone and End Bone names for each leg / limb. Compile the animation blueprint. Select the Walk node and observe the yellow diamonds on the end/foot bones. If you do not see yellow diamonds, double check the Character Root and Start/End bone names are correctly filled out on all limbs. Test the Walking behavior and tune the settings as required. Note: Be sure to setup the \"Related Limbs\" array as described below to prevent the feet from both stepping at the same time! Limb Settings Start Bone : The name of the bone at the origin of the leg. Usually a \"hip\" or \"shoulder\". End Bone : The name of the bone at the end of the leg. Usually the \"foot\". Limb Max Length Multiplier : By default, the raycasts use the initial distance between the Start Bone and End Bone (in the Reference pose) to determine the length of the raycasts used to determine the next footstep location. If the leg is modeled with a large amount of bend by default, you may want to adjust this to allow the raycasts more distance to search for a step. Step Length Multiplier : The step length is the maximum distance from the current planted foot position to the new target foot location (as determined by raycasts) before a \"step\" is triggered. Values between 0 and 1 will produce shorter steps. Values greater than 1 will create larger steps. Step Duration : The time, in seconds, that this foot will take from unplanting to replanting. Smaller values will produce faster stepping. Step Height : The maximum height, in centimeters, that this foot will reach at the apex of the step. Related Limbs : A list of integer values cooresponding to other limbs in the array that are related to this one. Related limbs will NOT unplant at the same time. Rotate Foot to Ground : A float value from 0 to 1 that determines how much the foot will orient to the ground collision normal. A value of 1 orients the feet exactly to the ground. Foot Collision Radius : A radius around the foot, in centimeters, that is considered \"off limits\" for other feet to occupy. The foot solver does collision checks to prevent other feet from planting within or passing through this collision radius. This prevents the dreaded \"kicking through your shins\" bug that plagues all strafing systems. Stepping Settings Step Max Reach Distance : A distance, in centimeters, that clamps the root motion to prevent the feet from searching for a new planted position too far from the prior planted position. This is only ever used when the root motion is too fast for the stride length and step duraction to keep up. Step Duration Multiplier : A global multiplier for all limbs to adjust the time per step. Step Height Multiplier : A global multiplier for all limbs to adjust the height per step. Step Height Curve (Optional) : A curve asset, normalized from 0 to 1, that describes how much of the foot height to apply for the duration of the step; where 0 is the start of the step and 1 is the end. Step Speed Curve (Optional) : A curve asset, normalized from 0 to 1, that scales the speed of the foot motion for the duration of the step; where 0 is the start of the step and 1 is the end. The default curve eases the foot into and out of steps. Teleport Distance : The maximum world space distance, in centimeters, that the feet are allowed to be from the Actor location. If the feet are detected beyond this distance, an instant single-frame teleportation is applied to force them back to the Actor's location. This may happen if the Actor is teleported, moved too quickly or when initially spawned. Collision Settings Set the Collision Channel to the Unreal trace channel that you want the limbs to raycast against. See the Ground Node docs for more information about how to set this up. Constraints and Solver Settings The Walk node is a custom wrapper of the core Power IK solver. See the Solver Node settings for a description of Bend Directions, Excluded Bones, Joint Limits and Max Squash/Stretch Iterations. Debug View You can view the foot plant locations and ray casts by hitting ~ to bring up the command console and executing the command: showdebug ANIMATION Use Page Up/Down to select the Actor with the Walk node and observe the debug view of the foot effectors, planted locations and raycasts. Testing Setup When first setting up a Walk node, it can be helpful to have a blank Actor blueprint to test with. This allows you to Eject while playing in editor, select the Actor and move/drag it with the mouse to observe how the Walking behavior is working. Create a blank Actor blueprint Add a Skeletal Mesh Component to the Actor Create an Animation blueprint for the Character Set the Skeletal Mesh Asset and Animation Blueprint on the Skeletal Mesh Actor Component Add a Power IK Walk node to the Animation Blueprint Setup the Walk node as described in the Setup a Walk Node section Now the setup is ready to test: Drag the Actor onto a floor into a test level. Hit Play, then hit Eject. Select the Actor and press W to enter move mode. Drag the Actor across the floor to observe the Walking behavior. In this way, you can iterate on the settings until the desired walking behavior is achieved. Once you are happy with the behavior, copy the Walk node into the final Animation Blueprint (whether AI controlled or player).","title":"Walk Node"},{"location":"unreal/walk_node/#walk-node","text":"Power IK comes with a dedicated Anim Graph node for procedurally generating walking animation. Experimental / Beta: This node is under active development. Future versions will support fully parameterized style adjustment for hip sway, tilt, bobbing, leaning, arm sway, running and more. But even in it's current form, we expect many users will find it useful.","title":"Walk Node"},{"location":"unreal/walk_node/#how-it-works","text":"It helps to understand how the Walk node works. The Walk node requires and responds to root motion. When an Actor containing a Skeletal Mesh running a Walk anim graph node is moved in world space, the Walk node responds to the motion by planting and unplanting the feet in a stepping behavior. Where to place the feet for the next step is determined by raycasting from the Actor's current world space location and rotation. So the Walk node requires a custom trace channel and sufficient world collision. Additionally, if the Actor is not rotated to face the movement direction, the Walk node will generate \"strafing\" type locomotion. The Walk node does not care about the source of the movement and works equally well if it is from AI navigation, a player controlled Pawn class, or even by manually translating or rotating the Actor with the mouse in the editor.","title":"How it Works"},{"location":"unreal/walk_node/#setup-a-walk-node","text":"In the Animation Graph, create a Power IK Walk node Connect the Output Pose of the Power IK Walk node Set the Character Root bone (see Ground Node docs for a description of how to choose a Character Root) In the Details section of the Walk node, click the + icon next to the Limbs array to add each foot. Set the Start Bone and End Bone names for each leg / limb. Compile the animation blueprint. Select the Walk node and observe the yellow diamonds on the end/foot bones. If you do not see yellow diamonds, double check the Character Root and Start/End bone names are correctly filled out on all limbs. Test the Walking behavior and tune the settings as required. Note: Be sure to setup the \"Related Limbs\" array as described below to prevent the feet from both stepping at the same time!","title":"Setup a Walk Node"},{"location":"unreal/walk_node/#limb-settings","text":"Start Bone : The name of the bone at the origin of the leg. Usually a \"hip\" or \"shoulder\". End Bone : The name of the bone at the end of the leg. Usually the \"foot\". Limb Max Length Multiplier : By default, the raycasts use the initial distance between the Start Bone and End Bone (in the Reference pose) to determine the length of the raycasts used to determine the next footstep location. If the leg is modeled with a large amount of bend by default, you may want to adjust this to allow the raycasts more distance to search for a step. Step Length Multiplier : The step length is the maximum distance from the current planted foot position to the new target foot location (as determined by raycasts) before a \"step\" is triggered. Values between 0 and 1 will produce shorter steps. Values greater than 1 will create larger steps. Step Duration : The time, in seconds, that this foot will take from unplanting to replanting. Smaller values will produce faster stepping. Step Height : The maximum height, in centimeters, that this foot will reach at the apex of the step. Related Limbs : A list of integer values cooresponding to other limbs in the array that are related to this one. Related limbs will NOT unplant at the same time. Rotate Foot to Ground : A float value from 0 to 1 that determines how much the foot will orient to the ground collision normal. A value of 1 orients the feet exactly to the ground. Foot Collision Radius : A radius around the foot, in centimeters, that is considered \"off limits\" for other feet to occupy. The foot solver does collision checks to prevent other feet from planting within or passing through this collision radius. This prevents the dreaded \"kicking through your shins\" bug that plagues all strafing systems.","title":"Limb Settings"},{"location":"unreal/walk_node/#stepping-settings","text":"Step Max Reach Distance : A distance, in centimeters, that clamps the root motion to prevent the feet from searching for a new planted position too far from the prior planted position. This is only ever used when the root motion is too fast for the stride length and step duraction to keep up. Step Duration Multiplier : A global multiplier for all limbs to adjust the time per step. Step Height Multiplier : A global multiplier for all limbs to adjust the height per step. Step Height Curve (Optional) : A curve asset, normalized from 0 to 1, that describes how much of the foot height to apply for the duration of the step; where 0 is the start of the step and 1 is the end. Step Speed Curve (Optional) : A curve asset, normalized from 0 to 1, that scales the speed of the foot motion for the duration of the step; where 0 is the start of the step and 1 is the end. The default curve eases the foot into and out of steps. Teleport Distance : The maximum world space distance, in centimeters, that the feet are allowed to be from the Actor location. If the feet are detected beyond this distance, an instant single-frame teleportation is applied to force them back to the Actor's location. This may happen if the Actor is teleported, moved too quickly or when initially spawned.","title":"Stepping Settings"},{"location":"unreal/walk_node/#collision-settings","text":"Set the Collision Channel to the Unreal trace channel that you want the limbs to raycast against. See the Ground Node docs for more information about how to set this up.","title":"Collision Settings"},{"location":"unreal/walk_node/#constraints-and-solver-settings","text":"The Walk node is a custom wrapper of the core Power IK solver. See the Solver Node settings for a description of Bend Directions, Excluded Bones, Joint Limits and Max Squash/Stretch Iterations.","title":"Constraints and Solver Settings"},{"location":"unreal/walk_node/#debug-view","text":"You can view the foot plant locations and ray casts by hitting ~ to bring up the command console and executing the command: showdebug ANIMATION Use Page Up/Down to select the Actor with the Walk node and observe the debug view of the foot effectors, planted locations and raycasts.","title":"Debug View"},{"location":"unreal/walk_node/#testing-setup","text":"When first setting up a Walk node, it can be helpful to have a blank Actor blueprint to test with. This allows you to Eject while playing in editor, select the Actor and move/drag it with the mouse to observe how the Walking behavior is working. Create a blank Actor blueprint Add a Skeletal Mesh Component to the Actor Create an Animation blueprint for the Character Set the Skeletal Mesh Asset and Animation Blueprint on the Skeletal Mesh Actor Component Add a Power IK Walk node to the Animation Blueprint Setup the Walk node as described in the Setup a Walk Node section Now the setup is ready to test: Drag the Actor onto a floor into a test level. Hit Play, then hit Eject. Select the Actor and press W to enter move mode. Drag the Actor across the floor to observe the Walking behavior. In this way, you can iterate on the settings until the desired walking behavior is achieved. Once you are happy with the behavior, copy the Walk node into the final Animation Blueprint (whether AI controlled or player).","title":"Testing Setup"}]}