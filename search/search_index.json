{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Power IK Documentation Welcome to the Power IK official documentation. Power IK comes in two flavors, an Unreal Plugin and a C++ SDK for integration into other software or game engines. This documentation includes information for both. To see Power IK in action visit poweranimated.com . Please report any issues or errors to support@poweranimated.com What is Power IK? Power IK is a full-body inverse kinematics solver that lets animators push and pull skeletons to dynamically and procedurally modify poses. How Is It Different? A normal IK solver operates on a single chain of joints by pulling them towards a single point in space. But with Power IK, the solver affects the entire skeleton with as many effectors as you like. With Power IK, effectors are associated with a joint in your skeleton. When you move the effectors, Power IK figures out how your skeleton should move to reach all of them at once. The final pose is the best compromise between all the competing effectors. If an effector is within reach, Power IK will reach it. If effectors cannot all be simultaneously reached, Power IK positions the skeleton evenly between them. If effectors are squashed towards each other, PowerIK will squish the bones into a smooth shape. Natural Poses There are many different possible poses that reach the same effectors; sometimes infinite. But Power IK attempts to achieve the most natural looking pose which is characterized as having smooth lines free from kinks; while distributing the motion across the whole body. This is the same as minimizing the \u201cenergy\u201d of the pose, which is what real-world creatures tend to do.","title":"Home"},{"location":"#power-ik-documentation","text":"Welcome to the Power IK official documentation. Power IK comes in two flavors, an Unreal Plugin and a C++ SDK for integration into other software or game engines. This documentation includes information for both. To see Power IK in action visit poweranimated.com . Please report any issues or errors to support@poweranimated.com","title":"Power IK Documentation"},{"location":"#what-is-power-ik","text":"Power IK is a full-body inverse kinematics solver that lets animators push and pull skeletons to dynamically and procedurally modify poses.","title":"What is Power IK?"},{"location":"#how-is-it-different","text":"A normal IK solver operates on a single chain of joints by pulling them towards a single point in space. But with Power IK, the solver affects the entire skeleton with as many effectors as you like. With Power IK, effectors are associated with a joint in your skeleton. When you move the effectors, Power IK figures out how your skeleton should move to reach all of them at once. The final pose is the best compromise between all the competing effectors. If an effector is within reach, Power IK will reach it. If effectors cannot all be simultaneously reached, Power IK positions the skeleton evenly between them. If effectors are squashed towards each other, PowerIK will squish the bones into a smooth shape.","title":"How Is It Different?"},{"location":"#natural-poses","text":"There are many different possible poses that reach the same effectors; sometimes infinite. But Power IK attempts to achieve the most natural looking pose which is characterized as having smooth lines free from kinks; while distributing the motion across the whole body. This is the same as minimizing the \u201cenergy\u201d of the pose, which is what real-world creatures tend to do.","title":"Natural Poses"},{"location":"sdk/getting_started_sdk/","text":"Power IK C++ SDK The Power IK C++ SDK allows you to integrate Power IK into any animation software that can link C++ and uses skeletal animation. This includes, but is not limited to: game engines VR training software content creation software industrial simulations robotics Power IK is commercially licensed priorietary software. To enquire about licensing our SDK, please contact support@poweranimated.com. Install the SDK Copy the entire SDK folder into a suitable location in your project directory. Add sdk/include to your project's include directories and include: sdk/include/PowerIK.h sdk/include/PowerIKMath.h sdk/include/PowerIKSettings.h Add /sdk/lib/PowerIK.lib to your project linker's additional dependencies. Then include PowerIK.h into the source file where you intend to integrate PowerIK. Note: : For dynamically linked binary distributions make sure that sdk/lib/Win64/POWERIK.dll is copied into your packaged build directory and is accessible to your .exe so that PowerIK can be linked at runtime. Initialization Right when your animation system is loading up, you need to initialize PowerIK. Instantiate a PowerIK::Solver() class. Call Solver.SetNumBones() to reserve space for the entire skeleton Call Solver.AddBone() for each bone in the skeleton Call Solver.SetRootBone() to specify the top bone (root of solver) Call Solver.AddEffector() for each effector (cannot add/remove effectors at runtime) On the first call to Solve(), PowerIK will allocate the necessary memory to support the bones and effectors that were added with AddBone(). Update Overview Once PowerIK is initialized, you're ready to start running it. At every tick in the simulation update loop, you need to: Give Power IK a new input pose. Update the effector settings (transforms, weights etc...). Call Solve() to generate a new pose. Copy the output pose out of the Solver and use it as desired NOTE: The input pose does not necessarily have to change from frame to frame. PowerIK will work equally well with static poses or animation (and both are useful in different scenarios). Update Details Your update process should look like this: Call Solver.SetBoneTransform() for all bones to provide the input pose (your animation) Call Solver.SetEffectorTransform() for each effector to set their positions and rotations Call Solver.Solve() to run Power IK Call Solver.GetBoneTransform() to get your output pose See AnimNode_PowerIK::CopySolverInputs() and AnimNode_PowerIK::CopySolverOutputs() for examples of how to do these steps in Unreal. Note on Transform Spaces: All transforms (input/ouput on both bones and effectors) are considered to be in Character Space ( Component Space in Unreal nomenclature). This space usually has it's origin at the character's feet or root bone. PowerIK solves in this space, so it is most efficient to avoid conversion to/from local/bone space or world space and simply keep all bones and effectors in Character Space . Note on PowerIK Math Library: PowerIK uses it's own portable math library, so you have to convert your positions and rotations to/from PowerIK::Vec3 and PowerIK::Quat format. These formats use plain 32-bit floats and should be convertable with any standard 3d-vector or quaternion format. Shutdown and Reset When the PowerIK::Solver() destructor is called, it releases all allocated memory. In cases where you want to add/remove characters using PowerIK often, it may be better to keep a few solvers in memory and recycle them. To avoid reallocating memory, you can call PowerIK::Solver().Reset(). This will clear the internal memory (without releasing it) to be re-used with a different skeleton or different set of effectors. You must re-add Bones and Effectors after calling Reset() and treat it like a new Solver(). If the new skeletons have more bones than before Reset(), additional allocations may occur. PowerIK never allocates memory after the first call to Solve().","title":"Getting Started"},{"location":"sdk/getting_started_sdk/#power-ik-c-sdk","text":"The Power IK C++ SDK allows you to integrate Power IK into any animation software that can link C++ and uses skeletal animation. This includes, but is not limited to: game engines VR training software content creation software industrial simulations robotics Power IK is commercially licensed priorietary software. To enquire about licensing our SDK, please contact support@poweranimated.com.","title":"Power IK C++ SDK"},{"location":"sdk/getting_started_sdk/#install-the-sdk","text":"Copy the entire SDK folder into a suitable location in your project directory. Add sdk/include to your project's include directories and include: sdk/include/PowerIK.h sdk/include/PowerIKMath.h sdk/include/PowerIKSettings.h Add /sdk/lib/PowerIK.lib to your project linker's additional dependencies. Then include PowerIK.h into the source file where you intend to integrate PowerIK. Note: : For dynamically linked binary distributions make sure that sdk/lib/Win64/POWERIK.dll is copied into your packaged build directory and is accessible to your .exe so that PowerIK can be linked at runtime.","title":"Install the SDK"},{"location":"sdk/getting_started_sdk/#initialization","text":"Right when your animation system is loading up, you need to initialize PowerIK. Instantiate a PowerIK::Solver() class. Call Solver.SetNumBones() to reserve space for the entire skeleton Call Solver.AddBone() for each bone in the skeleton Call Solver.SetRootBone() to specify the top bone (root of solver) Call Solver.AddEffector() for each effector (cannot add/remove effectors at runtime) On the first call to Solve(), PowerIK will allocate the necessary memory to support the bones and effectors that were added with AddBone().","title":"Initialization"},{"location":"sdk/getting_started_sdk/#update-overview","text":"Once PowerIK is initialized, you're ready to start running it. At every tick in the simulation update loop, you need to: Give Power IK a new input pose. Update the effector settings (transforms, weights etc...). Call Solve() to generate a new pose. Copy the output pose out of the Solver and use it as desired NOTE: The input pose does not necessarily have to change from frame to frame. PowerIK will work equally well with static poses or animation (and both are useful in different scenarios).","title":"Update Overview"},{"location":"sdk/getting_started_sdk/#update-details","text":"Your update process should look like this: Call Solver.SetBoneTransform() for all bones to provide the input pose (your animation) Call Solver.SetEffectorTransform() for each effector to set their positions and rotations Call Solver.Solve() to run Power IK Call Solver.GetBoneTransform() to get your output pose See AnimNode_PowerIK::CopySolverInputs() and AnimNode_PowerIK::CopySolverOutputs() for examples of how to do these steps in Unreal. Note on Transform Spaces: All transforms (input/ouput on both bones and effectors) are considered to be in Character Space ( Component Space in Unreal nomenclature). This space usually has it's origin at the character's feet or root bone. PowerIK solves in this space, so it is most efficient to avoid conversion to/from local/bone space or world space and simply keep all bones and effectors in Character Space . Note on PowerIK Math Library: PowerIK uses it's own portable math library, so you have to convert your positions and rotations to/from PowerIK::Vec3 and PowerIK::Quat format. These formats use plain 32-bit floats and should be convertable with any standard 3d-vector or quaternion format.","title":"Update Details"},{"location":"sdk/getting_started_sdk/#shutdown-and-reset","text":"When the PowerIK::Solver() destructor is called, it releases all allocated memory. In cases where you want to add/remove characters using PowerIK often, it may be better to keep a few solvers in memory and recycle them. To avoid reallocating memory, you can call PowerIK::Solver().Reset(). This will clear the internal memory (without releasing it) to be re-used with a different skeleton or different set of effectors. You must re-add Bones and Effectors after calling Reset() and treat it like a new Solver(). If the new skeletons have more bones than before Reset(), additional allocations may occur. PowerIK never allocates memory after the first call to Solve().","title":"Shutdown and Reset"},{"location":"sdk/settings_cog/","text":"PowerIK::CenterOfGravitySettings Struct struct POWERIK_LIB_API CenterOfGravitySettings The settings used to control the center of gravity constraint. float Alpha Amount to apply center of gravity constraint. Range is 0-1. Default is 0. float HorizAmount Amount to counteract root position in horizontal plane (relative to gravity). Range is 0-inf. Default is 1.2. float VertAmount Amount to counteract root position vertically (opposite to gravity). Range is 0-inf. Default is 0.3. float PullBodyAmount Amount to pull the rest of the body connected to the root. Range is 0-inf. Default is 0.4.","title":"Center of Gravity Settings"},{"location":"sdk/settings_cog/#powerikcenterofgravitysettings-struct","text":"","title":"PowerIK::CenterOfGravitySettings Struct"},{"location":"sdk/settings_cog/#struct-powerik_lib_api-centerofgravitysettings","text":"The settings used to control the center of gravity constraint.","title":"struct POWERIK_LIB_API CenterOfGravitySettings"},{"location":"sdk/settings_cog/#float-alpha","text":"Amount to apply center of gravity constraint. Range is 0-1. Default is 0.","title":"float Alpha"},{"location":"sdk/settings_cog/#float-horizamount","text":"Amount to counteract root position in horizontal plane (relative to gravity). Range is 0-inf. Default is 1.2.","title":"float HorizAmount"},{"location":"sdk/settings_cog/#float-vertamount","text":"Amount to counteract root position vertically (opposite to gravity). Range is 0-inf. Default is 0.3.","title":"float VertAmount"},{"location":"sdk/settings_cog/#float-pullbodyamount","text":"Amount to pull the rest of the body connected to the root. Range is 0-inf. Default is 0.4.","title":"float PullBodyAmount"},{"location":"sdk/settings_ground/","text":"PowerIK::GroundSettings Struct struct POWERIK_LIB_API GroundSettings The settings used control ground alignment. These settings have no effect unless at least 1 effector has IsGrounded on. Vec3 Normal Vector that is normal to the ground surface. Default is +Z. Vec3 StrideDirection Normalized vector that describes the direction of travel. float MaxGroundAngle Maximum angle relative to gravity vector to apply leaning and stride scaling. bool ScaleStride If true, stride of IsGrounded effectors will be scaled in Stride Direction. float UphillStrideScale Amount to scale stride when going uphill. Range is 0-1. Default 0.4. float DownhillStrideScale Amount to scale stride when going downhill. Range is 0-1. Default 0.2. float SidehillStrideScale Amount to scale stride when on a side-hill. Range is 0-1. Default 1.0. float SidehillPushOuterFeet Amount (in centimeters) to push outside feet outwards on sidehills. Default is 20.0. float SidehillPushInnerFeet Amount (in centimeters) to push inside feet outwards on sidehills. Default is 10.0. bool Lean If True, character root bone is rotated in opposite direction of ground normal. float UphillLean Amount to lean forward when going uphill. Range is 0-1. Default 0.3. float DownhillLean Amount to lean backward when going downhill. Range is 0-1. Default 0.5. float SidehillLean Amount to lean sideways into side-hills. Range is 0-1. Default 0.0. bool CounterLean If True, will counter lean CounterLeanBone. Usually this is the head. const char* CounterLeanBoneName Name of base of counter lean bone. Usually this is the base Head bone. float UphillCounterLean Amount to counter lean backward when going uphill. Range is 0-1. Default 0.8. float DownhillCounterLean Amount to counter lean backward when going downhill. Range is 0-1. Default 1.0. float SidehillCounterLean Amount to counter lean sideways into side-hills. Range is 0-1. Default 0.0. bool MoveRoot If True, character root bone position is gradually pushed vertically and horizontally. float UphillVertOffset Amount (in centimeters) to push the character root up/down when going UP hill. Default 10.0. float UphillHorizOffset Amount (in centimeters) to push the character root forward/back when going UP hill. Default -20.0. float DownhillVertOffset Amount (in centimeters) to push the character root up/down when going DOWN hill. Default 10.0. float DownhillHorizOffset Amount (in centimeters) to push the character root forward/back when going DOWN hill. Default 20.0. float SidehillVertOffset Amount (in centimeters) to push the character root up/down when on a SIDE hill. Default -10.0. float SidehillHorizOffset Amount (in centimeters) to push the character root forward/back when on a SIDE hill. Default -10.0. bool RotateFootToGround If True, feet are oriented to ground normal. float PitchFootAmount Amount to pitch foot to orient to up/down hills. Range is 0-1. Default 1.0. float RollFootAmount Amount to roll foot to orient to sidehills. Range is 0-1. Default 0.6.","title":"Ground Settings"},{"location":"sdk/settings_ground/#powerikgroundsettings-struct","text":"","title":"PowerIK::GroundSettings Struct"},{"location":"sdk/settings_ground/#struct-powerik_lib_api-groundsettings","text":"The settings used control ground alignment. These settings have no effect unless at least 1 effector has IsGrounded on.","title":"struct POWERIK_LIB_API GroundSettings"},{"location":"sdk/settings_ground/#vec3-normal","text":"Vector that is normal to the ground surface. Default is +Z.","title":"Vec3 Normal"},{"location":"sdk/settings_ground/#vec3-stridedirection","text":"Normalized vector that describes the direction of travel.","title":"Vec3 StrideDirection"},{"location":"sdk/settings_ground/#float-maxgroundangle","text":"Maximum angle relative to gravity vector to apply leaning and stride scaling.","title":"float MaxGroundAngle"},{"location":"sdk/settings_ground/#bool-scalestride","text":"If true, stride of IsGrounded effectors will be scaled in Stride Direction.","title":"bool ScaleStride"},{"location":"sdk/settings_ground/#float-uphillstridescale","text":"Amount to scale stride when going uphill. Range is 0-1. Default 0.4.","title":"float UphillStrideScale"},{"location":"sdk/settings_ground/#float-downhillstridescale","text":"Amount to scale stride when going downhill. Range is 0-1. Default 0.2.","title":"float DownhillStrideScale"},{"location":"sdk/settings_ground/#float-sidehillstridescale","text":"Amount to scale stride when on a side-hill. Range is 0-1. Default 1.0.","title":"float SidehillStrideScale"},{"location":"sdk/settings_ground/#float-sidehillpushouterfeet","text":"Amount (in centimeters) to push outside feet outwards on sidehills. Default is 20.0.","title":"float SidehillPushOuterFeet"},{"location":"sdk/settings_ground/#float-sidehillpushinnerfeet","text":"Amount (in centimeters) to push inside feet outwards on sidehills. Default is 10.0.","title":"float SidehillPushInnerFeet"},{"location":"sdk/settings_ground/#bool-lean","text":"If True, character root bone is rotated in opposite direction of ground normal.","title":"bool Lean"},{"location":"sdk/settings_ground/#float-uphilllean","text":"Amount to lean forward when going uphill. Range is 0-1. Default 0.3.","title":"float UphillLean"},{"location":"sdk/settings_ground/#float-downhilllean","text":"Amount to lean backward when going downhill. Range is 0-1. Default 0.5.","title":"float DownhillLean"},{"location":"sdk/settings_ground/#float-sidehilllean","text":"Amount to lean sideways into side-hills. Range is 0-1. Default 0.0.","title":"float SidehillLean"},{"location":"sdk/settings_ground/#bool-counterlean","text":"If True, will counter lean CounterLeanBone. Usually this is the head.","title":"bool CounterLean"},{"location":"sdk/settings_ground/#const-char-counterleanbonename","text":"Name of base of counter lean bone. Usually this is the base Head bone.","title":"const char* CounterLeanBoneName"},{"location":"sdk/settings_ground/#float-uphillcounterlean","text":"Amount to counter lean backward when going uphill. Range is 0-1. Default 0.8.","title":"float UphillCounterLean"},{"location":"sdk/settings_ground/#float-downhillcounterlean","text":"Amount to counter lean backward when going downhill. Range is 0-1. Default 1.0.","title":"float DownhillCounterLean"},{"location":"sdk/settings_ground/#float-sidehillcounterlean","text":"Amount to counter lean sideways into side-hills. Range is 0-1. Default 0.0.","title":"float SidehillCounterLean"},{"location":"sdk/settings_ground/#bool-moveroot","text":"If True, character root bone position is gradually pushed vertically and horizontally.","title":"bool MoveRoot"},{"location":"sdk/settings_ground/#float-uphillvertoffset","text":"Amount (in centimeters) to push the character root up/down when going UP hill. Default 10.0.","title":"float UphillVertOffset"},{"location":"sdk/settings_ground/#float-uphillhorizoffset","text":"Amount (in centimeters) to push the character root forward/back when going UP hill. Default -20.0.","title":"float UphillHorizOffset"},{"location":"sdk/settings_ground/#float-downhillvertoffset","text":"Amount (in centimeters) to push the character root up/down when going DOWN hill. Default 10.0.","title":"float DownhillVertOffset"},{"location":"sdk/settings_ground/#float-downhillhorizoffset","text":"Amount (in centimeters) to push the character root forward/back when going DOWN hill. Default 20.0.","title":"float DownhillHorizOffset"},{"location":"sdk/settings_ground/#float-sidehillvertoffset","text":"Amount (in centimeters) to push the character root up/down when on a SIDE hill. Default -10.0.","title":"float SidehillVertOffset"},{"location":"sdk/settings_ground/#float-sidehillhorizoffset","text":"Amount (in centimeters) to push the character root forward/back when on a SIDE hill. Default -10.0.","title":"float SidehillHorizOffset"},{"location":"sdk/settings_ground/#bool-rotatefoottoground","text":"If True, feet are oriented to ground normal.","title":"bool RotateFootToGround"},{"location":"sdk/settings_ground/#float-pitchfootamount","text":"Amount to pitch foot to orient to up/down hills. Range is 0-1. Default 1.0.","title":"float PitchFootAmount"},{"location":"sdk/settings_ground/#float-rollfootamount","text":"Amount to roll foot to orient to sidehills. Range is 0-1. Default 0.6.","title":"float RollFootAmount"},{"location":"sdk/settings_smoothing/","text":"PowerIK::EffectorSmoothingSettings Struct struct POWERIK_LIB_API EffectorSmoothingSettings The settings used control the position and rotation smoothing of effectors. bool SmoothPositionOverTime If true, the position of the effector will be smoothed over time. float MaxPositionSpeed Maximum speed an effector can move in centimeters per second. float MaxPositionDistance Maximum distance an effector can be from it's input position in centimeters. bool SmoothRotationOverTime If true, the rotation of the effector will be smoothed over time. float MaxDegreesSpeed Maximum speed an effector can rotate in degrees per second. float MaxDegreesDistance Maximum distance an effector angle can be from it's input rotation in degrees.","title":"Effector Smoothing Settings"},{"location":"sdk/settings_smoothing/#powerikeffectorsmoothingsettings-struct","text":"","title":"PowerIK::EffectorSmoothingSettings Struct"},{"location":"sdk/settings_smoothing/#struct-powerik_lib_api-effectorsmoothingsettings","text":"The settings used control the position and rotation smoothing of effectors.","title":"struct POWERIK_LIB_API EffectorSmoothingSettings"},{"location":"sdk/settings_smoothing/#bool-smoothpositionovertime","text":"If true, the position of the effector will be smoothed over time.","title":"bool SmoothPositionOverTime"},{"location":"sdk/settings_smoothing/#float-maxpositionspeed","text":"Maximum speed an effector can move in centimeters per second.","title":"float MaxPositionSpeed"},{"location":"sdk/settings_smoothing/#float-maxpositiondistance","text":"Maximum distance an effector can be from it's input position in centimeters.","title":"float MaxPositionDistance"},{"location":"sdk/settings_smoothing/#bool-smoothrotationovertime","text":"If true, the rotation of the effector will be smoothed over time.","title":"bool SmoothRotationOverTime"},{"location":"sdk/settings_smoothing/#float-maxdegreesspeed","text":"Maximum speed an effector can rotate in degrees per second.","title":"float MaxDegreesSpeed"},{"location":"sdk/settings_smoothing/#float-maxdegreesdistance","text":"Maximum distance an effector angle can be from it's input rotation in degrees.","title":"float MaxDegreesDistance"},{"location":"sdk/settings_solver/","text":"PowerIK::SolverSettings Struct struct POWERIK_LIB_API SolverSettings The settings used for the core solver. These setting only have to be set once. Though they can all be changed at runtime if desired. unsigned int SquashIterations Number of iterations to determine squashed limb shape. Default is 6. unsigned int StretchIterations Number of iterations to determine stretched limb shape. Default is 6. Vec3 WorldUpNormal Up direction of world. Used for Center of Gravity and Grounding. Default is +Z (Unreal). float RootRotationMultiplier Amount to rotate the root in response to effectors. Default is 1.0. Value as high as 3 or 4 may be necessary in some cases.","title":"Solver Settings"},{"location":"sdk/settings_solver/#poweriksolversettings-struct","text":"","title":"PowerIK::SolverSettings Struct"},{"location":"sdk/settings_solver/#struct-powerik_lib_api-solversettings","text":"The settings used for the core solver. These setting only have to be set once. Though they can all be changed at runtime if desired.","title":"struct POWERIK_LIB_API SolverSettings"},{"location":"sdk/settings_solver/#unsigned-int-squashiterations","text":"Number of iterations to determine squashed limb shape. Default is 6.","title":"unsigned int SquashIterations"},{"location":"sdk/settings_solver/#unsigned-int-stretchiterations","text":"Number of iterations to determine stretched limb shape. Default is 6.","title":"unsigned int StretchIterations"},{"location":"sdk/settings_solver/#vec3-worldupnormal","text":"Up direction of world. Used for Center of Gravity and Grounding. Default is +Z (Unreal).","title":"Vec3 WorldUpNormal"},{"location":"sdk/settings_solver/#float-rootrotationmultiplier","text":"Amount to rotate the root in response to effectors. Default is 1.0. Value as high as 3 or 4 may be necessary in some cases.","title":"float RootRotationMultiplier"},{"location":"sdk/solver/","text":"PowerIK::Solver Class class POWERIK_LIB_API Solver The core solver class for PowerIK. Solver() Creates a new instance of a PowerIK solver. Do this once per animated skeleton. void Solve(const float DeltaTime, const float Alpha) Call this every tick to generate a new pose based on the input pose and the effectors. Parameters: DeltaTime \u2014 - the time (in seconds since the last call to Solve(). PowerIK is deterministic, this is only needed for effector smoothing. Alpha \u2014 - blend the entire effect of the solver off and on (0-1). At 0, the solve is skipped entirely and the input pose is completely unchanged. void Reset() Call this to reset all internal data structures. Will not deallocate. Useful for recycling solver memory. void SetNumBones(int NumBones) Call this on a new Solver() or only AFTER calling Reset() to expand/allocate space for a new skeleton. int GetNumBones() Get how many bones have been added to the Solver. void AddBone( const int Index, const char* BoneName, const int ParentIndex) Call this for each bone AFTER calling SetNumBones(). Supplies hierarchy information to solver. Parameters: Index \u2014 - the index of the bone. Index must be >= 0 and less than NumBones. BoneName \u2014 - the string name of the Bone. This name must match the name passed to AddEffector() ParentIndex \u2014 - the index of the bone this bone is parented to or -1 for the root (no parent). int AddEffector(const char* BoneName) Call this AFTER called AddBone() for the whole skeleton. Adds an effector to a given bone (by name). Parameters: BoneName \u2014 - the string name of the Bone to affect. This name must match the name passed to AddBone(). Returns: - the index of the newly created effector. Store this and use it in SetEffectorTransform() void SetRootBone(const int BoneIndex) Tell the solver what the root bone is. All bones ABOVE the root are culled from the solver entirely. Parameters: BoneIndex \u2014 - all of the ground settings const char* GetRootBoneName() Get name of the currently set root bone. Returns: - a pointer to array of char holding the name of the root bone. Returns empty string if no root has been set. void SetSolverSettings(const SolverSettings& Settings) Optional method to modify internal solver settings like iteration counts. Parameters: Settings \u2014 - all the solver settings void SetCOGSettings(const CenterOfGravitySettings& Settings) Optional method to setup Center of Gravity constraint on root bone. Parameters: Settings \u2014 - all of the center of gravity settings void SetGroundSettings(const GroundSettings& Settings) Optional method to setup Ground settings. Only used if IsGrounded is True on an Effector. Parameters: Settings \u2014 - all of the ground settings void SetBoneTransform( const int Index, const Vec3& Position, const Quat& Rotation) Call this every tick, for each bone, before Solve() to update the input pose. Parameters: Index \u2014 - the index of the bone. Index must be >= 0 and less than NumBones. Position \u2014 - the Character Space 3d position of the bone Rotation \u2014 - the Character Space rotation of the bone as a quaternion void GetBoneTransform( const int Index, Vec3& OutPosition, Quat& OutRotation) Call this every tick, for each bone, AFTER Solve() to get the generated output pose. Parameters: Index \u2014 - the index of the bone. Index must be >= 0 and less than NumBones. Position \u2014 - the Character Space 3d position of the bone Rotation \u2014 - the Character Space rotation of the bone as a quaternion void SetEffectorTransform( const int Index, const Vec3& Position, const Quat& Rotation, const bool IsAdditive, const bool RotateBone, const bool RotateLimb) Optionally call this every tick, for each effector, before Solve() to update the effector transform settings. Parameters: Index \u2014 - the index of the effector (as returned from AddEffector) Position \u2014 - the Character Space 3d position of the effector Rotation \u2014 - the Character Space rotation of the effector as a quaternion IsAdditive \u2014 - if True, Position and Rotation are considered relative to input pose of bone RotateBone \u2014 - if True, affected Bone will rotate to match effector rotation RotateLimb \u2014 - if True, Bones near this effector will be rotated with the effector void SetEffectorWeights( const int Index, const float Alpha, const float PullWeight, const bool NormalizePulling, const Vec3& PositivePullFactor, const Vec3& NegativePullFactor) Optionally call this every tick, for each effector, before Solve() to update the effector weight settings. Parameters: Index \u2014 - the index of the effector (as returned from AddEffector) Alpha \u2014 - used to blend the effect of the effector on/off. Ranges from 0 to 1. PullWeight \u2014 - determines the degree of effect this effector has on the rest of the body. Normalized relative to all other PullWeight values. NormalizePulling \u2014 - if True, total PullWeight on body is normalized to 1 to avoid over/under shooting. PositivePullFactor \u2014 - multiplies effect of this effector on the rest of the body in the positive directions NegativePullFactor \u2014 - multiplies effect of this effector on the rest of the body in the negative directions void SetEffectorSettings( const int Index, const bool IsGrounded, const bool AffectsCenterOfGravity) Optionally call this every tick, for each effector, before Solve() to update the effector weight settings. Parameters: Index \u2014 - the index of the effector (as returned from AddEffector) IsGrounded \u2014 - multiplies effect of this effector on the rest of the body in the positive directions AffectsCenterOfGravity \u2014 - multiplies effect of this effector on the rest of the body in the negative directions void SetEffectorSmoothing( const int Index, const EffectorSmoothingSettings& Settings) Optionally call this to smooth an effector's position and/or rotation over time Parameters: Index \u2014 - the index of the effector (as returned from AddEffector) Settings \u2014 - the position and rotation smoothing settings void SetBoneBendDirection( const int Index, const Vec3& Direction) Optionally call this to specify a custom bending direction for a single bone Parameters: Index \u2014 - the index of the bone (as returned from AddBone) Direction \u2014 - a 3d vector in the local space of the bone that is the direction the bone will move in when bending void SetBoneLimits( const int Index, const float Stiffness, const bool UseLimits, const Vec3& MinAngles, const Vec3& MaxAngles, const bool NegateXAxis) EXPERIMENTAL! Optionally call this to specify a set of limits and stiffness for a bone Parameters: Index \u2014 - the index of the bone (as returned from AddBone) Stiffness \u2014 - ranges from 0 to 1. Default is 0. At 1 the bone is completely rigid and will be removed from the solve entirely. UseLimits \u2014 - turn limits on/off. MinAngles \u2014 - minimum allowable X, Y and Z rotations relative to parent MaxAngles \u2014 - maximum allowable X, Y and Z rotations relative to parent NegateXAxis \u2014 - consider limits in opposite direction along X-axis bool GetBoneLimits( const int Index, Vec3& OutMinLimits, Vec3& OutMaxLimits, bool& OutNegateXAxis) Optionally call this to get the limits for a bone. If the bone has no limits Parameters: Index \u2014 - the index of the bone (as returned from AddBone) OutMinLimits \u2014 - minimum allowable X, Y and Z rotations relative to parent OutMaxLimits \u2014 - maximum allowable X, Y and Z rotations relative to parent OutNegateXAxis \u2014 - consider limits in opposite direction along X-axis Returns: - True if the bone has limits, false otherwise (all Out values will be untouched)","title":"Solver Class"},{"location":"sdk/solver/#poweriksolver-class","text":"","title":"PowerIK::Solver Class"},{"location":"sdk/solver/#class-powerik_lib_api-solver","text":"The core solver class for PowerIK.","title":"class POWERIK_LIB_API Solver"},{"location":"sdk/solver/#solver","text":"Creates a new instance of a PowerIK solver. Do this once per animated skeleton.","title":"Solver()"},{"location":"sdk/solver/#void-solveconst-float-deltatime-const-float-alpha","text":"Call this every tick to generate a new pose based on the input pose and the effectors. Parameters: DeltaTime \u2014 - the time (in seconds since the last call to Solve(). PowerIK is deterministic, this is only needed for effector smoothing. Alpha \u2014 - blend the entire effect of the solver off and on (0-1). At 0, the solve is skipped entirely and the input pose is completely unchanged.","title":"void Solve(const float DeltaTime, const float Alpha)"},{"location":"sdk/solver/#void-reset","text":"Call this to reset all internal data structures. Will not deallocate. Useful for recycling solver memory.","title":"void Reset()"},{"location":"sdk/solver/#void-setnumbonesint-numbones","text":"Call this on a new Solver() or only AFTER calling Reset() to expand/allocate space for a new skeleton.","title":"void SetNumBones(int NumBones)"},{"location":"sdk/solver/#int-getnumbones","text":"Get how many bones have been added to the Solver.","title":"int GetNumBones()"},{"location":"sdk/solver/#void-addbone-const-int-index-const-char-bonename-const-int-parentindex","text":"Call this for each bone AFTER calling SetNumBones(). Supplies hierarchy information to solver. Parameters: Index \u2014 - the index of the bone. Index must be >= 0 and less than NumBones. BoneName \u2014 - the string name of the Bone. This name must match the name passed to AddEffector() ParentIndex \u2014 - the index of the bone this bone is parented to or -1 for the root (no parent).","title":"void AddBone(   const int Index,   const char* BoneName,   const int ParentIndex)"},{"location":"sdk/solver/#int-addeffectorconst-char-bonename","text":"Call this AFTER called AddBone() for the whole skeleton. Adds an effector to a given bone (by name). Parameters: BoneName \u2014 - the string name of the Bone to affect. This name must match the name passed to AddBone(). Returns: - the index of the newly created effector. Store this and use it in SetEffectorTransform()","title":"int AddEffector(const char* BoneName)"},{"location":"sdk/solver/#void-setrootboneconst-int-boneindex","text":"Tell the solver what the root bone is. All bones ABOVE the root are culled from the solver entirely. Parameters: BoneIndex \u2014 - all of the ground settings","title":"void SetRootBone(const int BoneIndex)"},{"location":"sdk/solver/#const-char-getrootbonename","text":"Get name of the currently set root bone. Returns: - a pointer to array of char holding the name of the root bone. Returns empty string if no root has been set.","title":"const char* GetRootBoneName()"},{"location":"sdk/solver/#void-setsolversettingsconst-solversettingsamp-settings","text":"Optional method to modify internal solver settings like iteration counts. Parameters: Settings \u2014 - all the solver settings","title":"void SetSolverSettings(const SolverSettings&amp;amp; Settings)"},{"location":"sdk/solver/#void-setcogsettingsconst-centerofgravitysettingsamp-settings","text":"Optional method to setup Center of Gravity constraint on root bone. Parameters: Settings \u2014 - all of the center of gravity settings","title":"void SetCOGSettings(const CenterOfGravitySettings&amp;amp; Settings)"},{"location":"sdk/solver/#void-setgroundsettingsconst-groundsettingsamp-settings","text":"Optional method to setup Ground settings. Only used if IsGrounded is True on an Effector. Parameters: Settings \u2014 - all of the ground settings","title":"void SetGroundSettings(const GroundSettings&amp;amp; Settings)"},{"location":"sdk/solver/#void-setbonetransform-const-int-index-const-vec3amp-position-const-quatamp-rotation","text":"Call this every tick, for each bone, before Solve() to update the input pose. Parameters: Index \u2014 - the index of the bone. Index must be >= 0 and less than NumBones. Position \u2014 - the Character Space 3d position of the bone Rotation \u2014 - the Character Space rotation of the bone as a quaternion","title":"void SetBoneTransform(   const int Index,   const Vec3&amp;amp; Position,   const Quat&amp;amp; Rotation)"},{"location":"sdk/solver/#void-getbonetransform-const-int-index-vec3amp-outposition-quatamp-outrotation","text":"Call this every tick, for each bone, AFTER Solve() to get the generated output pose. Parameters: Index \u2014 - the index of the bone. Index must be >= 0 and less than NumBones. Position \u2014 - the Character Space 3d position of the bone Rotation \u2014 - the Character Space rotation of the bone as a quaternion","title":"void GetBoneTransform(   const int Index,   Vec3&amp;amp; OutPosition,   Quat&amp;amp; OutRotation)"},{"location":"sdk/solver/#void-seteffectortransform-const-int-index-const-vec3amp-position-const-quatamp-rotation-const-bool-isadditive-const-bool-rotatebone-const-bool-rotatelimb","text":"Optionally call this every tick, for each effector, before Solve() to update the effector transform settings. Parameters: Index \u2014 - the index of the effector (as returned from AddEffector) Position \u2014 - the Character Space 3d position of the effector Rotation \u2014 - the Character Space rotation of the effector as a quaternion IsAdditive \u2014 - if True, Position and Rotation are considered relative to input pose of bone RotateBone \u2014 - if True, affected Bone will rotate to match effector rotation RotateLimb \u2014 - if True, Bones near this effector will be rotated with the effector","title":"void SetEffectorTransform(   const int Index,   const Vec3&amp;amp; Position,   const Quat&amp;amp; Rotation,   const bool IsAdditive,   const bool RotateBone,   const bool RotateLimb)"},{"location":"sdk/solver/#void-seteffectorweights-const-int-index-const-float-alpha-const-float-pullweight-const-bool-normalizepulling-const-vec3amp-positivepullfactor-const-vec3amp-negativepullfactor","text":"Optionally call this every tick, for each effector, before Solve() to update the effector weight settings. Parameters: Index \u2014 - the index of the effector (as returned from AddEffector) Alpha \u2014 - used to blend the effect of the effector on/off. Ranges from 0 to 1. PullWeight \u2014 - determines the degree of effect this effector has on the rest of the body. Normalized relative to all other PullWeight values. NormalizePulling \u2014 - if True, total PullWeight on body is normalized to 1 to avoid over/under shooting. PositivePullFactor \u2014 - multiplies effect of this effector on the rest of the body in the positive directions NegativePullFactor \u2014 - multiplies effect of this effector on the rest of the body in the negative directions","title":"void SetEffectorWeights(   const int Index,   const float Alpha,   const float PullWeight,   const bool NormalizePulling,   const Vec3&amp;amp; PositivePullFactor,   const Vec3&amp;amp; NegativePullFactor)"},{"location":"sdk/solver/#void-seteffectorsettings-const-int-index-const-bool-isgrounded-const-bool-affectscenterofgravity","text":"Optionally call this every tick, for each effector, before Solve() to update the effector weight settings. Parameters: Index \u2014 - the index of the effector (as returned from AddEffector) IsGrounded \u2014 - multiplies effect of this effector on the rest of the body in the positive directions AffectsCenterOfGravity \u2014 - multiplies effect of this effector on the rest of the body in the negative directions","title":"void SetEffectorSettings(   const int Index,   const bool IsGrounded,   const bool AffectsCenterOfGravity)"},{"location":"sdk/solver/#void-seteffectorsmoothing-const-int-index-const-effectorsmoothingsettingsamp-settings","text":"Optionally call this to smooth an effector's position and/or rotation over time Parameters: Index \u2014 - the index of the effector (as returned from AddEffector) Settings \u2014 - the position and rotation smoothing settings","title":"void SetEffectorSmoothing(   const int Index,   const EffectorSmoothingSettings&amp;amp; Settings)"},{"location":"sdk/solver/#void-setbonebenddirection-const-int-index-const-vec3amp-direction","text":"Optionally call this to specify a custom bending direction for a single bone Parameters: Index \u2014 - the index of the bone (as returned from AddBone) Direction \u2014 - a 3d vector in the local space of the bone that is the direction the bone will move in when bending","title":"void SetBoneBendDirection(   const int Index,   const Vec3&amp;amp; Direction)"},{"location":"sdk/solver/#void-setbonelimits-const-int-index-const-float-stiffness-const-bool-uselimits-const-vec3amp-minangles-const-vec3amp-maxangles-const-bool-negatexaxis","text":"EXPERIMENTAL! Optionally call this to specify a set of limits and stiffness for a bone Parameters: Index \u2014 - the index of the bone (as returned from AddBone) Stiffness \u2014 - ranges from 0 to 1. Default is 0. At 1 the bone is completely rigid and will be removed from the solve entirely. UseLimits \u2014 - turn limits on/off. MinAngles \u2014 - minimum allowable X, Y and Z rotations relative to parent MaxAngles \u2014 - maximum allowable X, Y and Z rotations relative to parent NegateXAxis \u2014 - consider limits in opposite direction along X-axis","title":"void SetBoneLimits(   const int Index,   const float Stiffness,   const bool UseLimits,   const Vec3&amp;amp; MinAngles,   const Vec3&amp;amp; MaxAngles,   const bool NegateXAxis)"},{"location":"sdk/solver/#bool-getbonelimits-const-int-index-vec3amp-outminlimits-vec3amp-outmaxlimits-boolamp-outnegatexaxis","text":"Optionally call this to get the limits for a bone. If the bone has no limits Parameters: Index \u2014 - the index of the bone (as returned from AddBone) OutMinLimits \u2014 - minimum allowable X, Y and Z rotations relative to parent OutMaxLimits \u2014 - maximum allowable X, Y and Z rotations relative to parent OutNegateXAxis \u2014 - consider limits in opposite direction along X-axis Returns: - True if the bone has limits, false otherwise (all Out values will be untouched)","title":"bool GetBoneLimits(   const int Index,   Vec3&amp;amp; OutMinLimits,   Vec3&amp;amp; OutMaxLimits,   bool&amp;amp; OutNegateXAxis)"},{"location":"unreal/bend_directions/","text":"Bend Directions By default, Power IK will bend limbs in the direction that they are bent in the input pose. Sometimes the input pose does not give a good enough hint of which direction to bend in. So you must explicitly tell the solver which direction a given bone is meant to bend in. If you witness knees and elbows bending off-axis, chances are you need to specify a custom Bend Direction. Specify a Custom Bend Direction Determine the name of the bone that is bending in the wrong direction. You can find this in the Skeleton editor in Unreal. Determine what local axis (in bone space) that points in the direction the limb should bend. For example, if the Y axis points in the direction of the knee, the bend vector is 0, 1, 0. Make note of this vector. Select the Power IK Solver node and in the detail panel locate the Constraints section. Click the + icon next to Bend Directions to add a new Bend Direction to the array. Add the Bone Name and Bend Direction vector. Save and compile the animation blueprint. The specified bone will now bend in the direction of the vector. The following image shows the custom bend directions appropriate for the Unreal Mannequin. Notice that the Right side bones have their vectors negated. How to Determine the Bend Vector You can verify these vectors by selecting the bone in the skeleton editor and observing the axis that points in the direction the bone should bend. In the image below you can see the Mannequin's left knee should point in the positive Y direction, so the bend vector is (0, 1, 0).","title":"Bend Directions"},{"location":"unreal/bend_directions/#bend-directions","text":"By default, Power IK will bend limbs in the direction that they are bent in the input pose. Sometimes the input pose does not give a good enough hint of which direction to bend in. So you must explicitly tell the solver which direction a given bone is meant to bend in. If you witness knees and elbows bending off-axis, chances are you need to specify a custom Bend Direction.","title":"Bend Directions"},{"location":"unreal/bend_directions/#specify-a-custom-bend-direction","text":"Determine the name of the bone that is bending in the wrong direction. You can find this in the Skeleton editor in Unreal. Determine what local axis (in bone space) that points in the direction the limb should bend. For example, if the Y axis points in the direction of the knee, the bend vector is 0, 1, 0. Make note of this vector. Select the Power IK Solver node and in the detail panel locate the Constraints section. Click the + icon next to Bend Directions to add a new Bend Direction to the array. Add the Bone Name and Bend Direction vector. Save and compile the animation blueprint. The specified bone will now bend in the direction of the vector. The following image shows the custom bend directions appropriate for the Unreal Mannequin. Notice that the Right side bones have their vectors negated.","title":"Specify a Custom Bend Direction"},{"location":"unreal/bend_directions/#how-to-determine-the-bend-vector","text":"You can verify these vectors by selecting the bone in the skeleton editor and observing the axis that points in the direction the bone should bend. In the image below you can see the Mannequin's left knee should point in the positive Y direction, so the bend vector is (0, 1, 0).","title":"How to Determine the Bend Vector"},{"location":"unreal/center_of_gravity/","text":"Center of Gravity Constraint The Center of Gravity Constraint operates on the Character Root bone (typically the pelvis or hips). It works to pull the hips back over the center of gravity when other body parts (like the head or hands) are trying to pull it off-center. This was developed for creating 3-point VR tracking rigs. But may be useful in other scenarios as well. The center of gravity is defined as the average position of any effectors with the \"Affects Center of Gravity\" flag turned on. To enable Center of Gravity: Add an Effector to each foot. Set Affects Center of Gravity on for all the foot effectors. In the Solver node, set the Center of Gravity Alpha value to 1.0. Test the setup by pulling the hips off center. The attributes of the contraint are important for tuning the effect: Alpha : a global blend of the effect, 0 is off (and computation is skipped) Horiz Amount : this is the amount that the hips compensate in the opposite direction they are being pulled. A value of 1.0 will pin the hips (horizontally) to the center of gravity. Values greater than one will push the hip in the opposite direction which can give the impression of keeping the overall body balanced. Vert Amount : this is the amount that the hips are raised up when pulled down and off-center. This forces a biped into a bent-over pose instead of a crouched leaning pose. This tends to look more natural when leaning down. This has to be tuned depending on the shape of the character's body. Pull Body Amount : This controls how much the pelvis will pull the rest of the body back towards the center of gravity. At low values, it will yank the pelvis back while leaving the torso looking unnaturally vertical and kinked. The default value works good for humans.","title":"Center of Gravity"},{"location":"unreal/center_of_gravity/#center-of-gravity-constraint","text":"The Center of Gravity Constraint operates on the Character Root bone (typically the pelvis or hips). It works to pull the hips back over the center of gravity when other body parts (like the head or hands) are trying to pull it off-center. This was developed for creating 3-point VR tracking rigs. But may be useful in other scenarios as well. The center of gravity is defined as the average position of any effectors with the \"Affects Center of Gravity\" flag turned on. To enable Center of Gravity: Add an Effector to each foot. Set Affects Center of Gravity on for all the foot effectors. In the Solver node, set the Center of Gravity Alpha value to 1.0. Test the setup by pulling the hips off center. The attributes of the contraint are important for tuning the effect: Alpha : a global blend of the effect, 0 is off (and computation is skipped) Horiz Amount : this is the amount that the hips compensate in the opposite direction they are being pulled. A value of 1.0 will pin the hips (horizontally) to the center of gravity. Values greater than one will push the hip in the opposite direction which can give the impression of keeping the overall body balanced. Vert Amount : this is the amount that the hips are raised up when pulled down and off-center. This forces a biped into a bent-over pose instead of a crouched leaning pose. This tends to look more natural when leaning down. This has to be tuned depending on the shape of the character's body. Pull Body Amount : This controls how much the pelvis will pull the rest of the body back towards the center of gravity. At low values, it will yank the pelvis back while leaving the torso looking unnaturally vertical and kinked. The default value works good for humans.","title":"Center of Gravity Constraint"},{"location":"unreal/common_issues/","text":"Common Issues Report Bugs For the fastest response, including community help, please post your issue in the official Power IK discord channel . If you are having trouble using Power IK, or you encounter issues or bugs, please send a detailed account of the issue to: support@poweranimated.com . We will do our best to make sure Power IK is working for you. \u201cI don\u2019t see any effect on my skeleton.\u201d There may be several reasons for this: Check the Output Log for warnings. It could be that the Solver node was not able to find the Character Root, Ground Plane Bone or one of the Effector bones. Check that you have the correct animation blueprint running on your actor. Check that the Power IK Solver has it\u2019s input and output poses plugged in. Check that you are actually telling the effectors to move. By default they are set to Relative to Input Pose with a translation and rotation of zero. This has no effect on your skeleton! \u201cMy character disappears after adding Power IK.\u201d When using World Space effectors, it\u2019s possible to pull your character very far away from their capsule. Check the values going into the translation channel of the effectors and make sure you aren\u2019t yanking the character back to the origin or to some far off place in space. Also you make need to put a small delay after Spawn (0.2 seconds) to allow time for your animation systems initialize. If Power IK recieves world space values of zero, it can throw the model back to the world origin, which can cause the LOD system to cull the actor. \u201cMy limbs are bending in the wrong direction.\u201d Power IK needs a hint of what direction to bend in. If you supply a perfectly straight input pose it may choose a bending angle which \u201cbreaks\u201d your character. You have two options to fix this: Supply an input pose that has at least some bend in it. Specify a custom Bend Direction","title":"Common Issues"},{"location":"unreal/common_issues/#common-issues","text":"","title":"Common Issues"},{"location":"unreal/common_issues/#report-bugs","text":"For the fastest response, including community help, please post your issue in the official Power IK discord channel . If you are having trouble using Power IK, or you encounter issues or bugs, please send a detailed account of the issue to: support@poweranimated.com . We will do our best to make sure Power IK is working for you.","title":"Report Bugs"},{"location":"unreal/common_issues/#i-dont-see-any-effect-on-my-skeleton","text":"There may be several reasons for this: Check the Output Log for warnings. It could be that the Solver node was not able to find the Character Root, Ground Plane Bone or one of the Effector bones. Check that you have the correct animation blueprint running on your actor. Check that the Power IK Solver has it\u2019s input and output poses plugged in. Check that you are actually telling the effectors to move. By default they are set to Relative to Input Pose with a translation and rotation of zero. This has no effect on your skeleton!","title":"\u201cI don\u2019t see any effect on my skeleton.\u201d"},{"location":"unreal/common_issues/#my-character-disappears-after-adding-power-ik","text":"When using World Space effectors, it\u2019s possible to pull your character very far away from their capsule. Check the values going into the translation channel of the effectors and make sure you aren\u2019t yanking the character back to the origin or to some far off place in space. Also you make need to put a small delay after Spawn (0.2 seconds) to allow time for your animation systems initialize. If Power IK recieves world space values of zero, it can throw the model back to the world origin, which can cause the LOD system to cull the actor.","title":"\u201cMy character disappears after adding Power IK.\u201d"},{"location":"unreal/common_issues/#my-limbs-are-bending-in-the-wrong-direction","text":"Power IK needs a hint of what direction to bend in. If you supply a perfectly straight input pose it may choose a bending angle which \u201cbreaks\u201d your character. You have two options to fix this: Supply an input pose that has at least some bend in it. Specify a custom Bend Direction","title":"\u201cMy limbs are bending in the wrong direction.\u201d"},{"location":"unreal/debugging/","text":"Debugging Power IK Gaining insight into what Power IK is doing is crucial to helping you design a functional IK rig. Anim Graph Debug View When setting up Power IK in the Animation Graph, it will show yellow diamonds in the preview window demonstrating which bones have effectors attached to them. Select the Power IK solver node to see the debug view. Note: If you do not see effectors where you expect them, double-check that you have the bone names set correctly on your effector inputs, and the solver is plugged into the graph (input and output pose). You can adjust the scale of the debug drawing on the solver node: Play In Editor Debug View While playing in editor, hit ~ to bring up the console and execute the command: showdebug ANIMATION Then use the Page Up/Down to cycle through the anim instances in your scene. This gives you some information about what Power IK is doing. You should see blue diamonds on each effector, as well as a print out showing how many effectors the solver is running and the current Alpha value.","title":"Debugging"},{"location":"unreal/debugging/#debugging-power-ik","text":"Gaining insight into what Power IK is doing is crucial to helping you design a functional IK rig.","title":"Debugging Power IK"},{"location":"unreal/debugging/#anim-graph-debug-view","text":"When setting up Power IK in the Animation Graph, it will show yellow diamonds in the preview window demonstrating which bones have effectors attached to them. Select the Power IK solver node to see the debug view. Note: If you do not see effectors where you expect them, double-check that you have the bone names set correctly on your effector inputs, and the solver is plugged into the graph (input and output pose). You can adjust the scale of the debug drawing on the solver node:","title":"Anim Graph Debug View"},{"location":"unreal/debugging/#play-in-editor-debug-view","text":"While playing in editor, hit ~ to bring up the console and execute the command: showdebug ANIMATION Then use the Page Up/Down to cycle through the anim instances in your scene. This gives you some information about what Power IK is doing. You should see blue diamonds on each effector, as well as a print out showing how many effectors the solver is running and the current Alpha value.","title":"Play In Editor Debug View"},{"location":"unreal/effector_settings/","text":"Effectors What is a Power IK Effector? Effectors are how you tell the solver what bone of the skeleton you want to pull, and where you want it to go. Each effector is associated with a single bone in the skeleton and supplies a position and rotation for that bone to reach towards. If you only add 1 effector, it will pull your entire skeleton as though your skeleton were parented to it. Once you have multiple effectors, the solver is able to do interesting work by creating a pose that reaches both effectors simultaneously. For example, by adding an effector to both feet of an ogre, you can pull 1 foot upwards while leaving the other foot on the ground. The hips of the ogre will translate and rotate to help the overall skeleton reach this desired goal. Bone Name This is the name of the bone you want this effector to affect. The name in this field must match the name in the skeleton precisely. Bones cannot be affected by more than 1 effector. Position and Rotation Space The Position (Vector) and Rotation (Rotator) inputs are both considered to be in 1 of three spaces: Relative to Input Pose : interprets inputs as offsets relative to the affected bone in the pose that is passed as input. This is the default space. World Space : interprets inputs as world space. Component Space : interprets inputs as being relative to the root of the Skeletal Mesh. By default, the space of the effector is Relative to Input Pose with zero position and rotation values. This is essentially telling the solver to not modify the input pose (ie do nothing). All three spaces are useful in different scenarios. But the most common is Relative to Input Pose . This can be used to nudge the skeleton from it\u2019s animated position. For example, by taking a walking animation and pulling the feel outwards and the hips down you can turn a walk into a crouch-walk. Pull Weight The Pull Weight of an effector determines how much influence the effector has over the whole body relative to other effectors . If all the Pull Weight values are the same, they all have the same relative influence on the skeleton. This is regardless of their absolute values. In cases where you want simple reaching behavior, leaving all the Pull Weights set to 1.0 will split the influence of the effectors evenly. Power IK weights the unaffected parts of the skeleton based on distance (along the skeleton) to your effectors. So you should get decent influence distribution by default. Adjusting Pull Weights is sometimes necessary in situations where you need one part of the body to dominate the pose. For example, to setup a 3-point VR tracking solver, you would want 100% of the weight on the head tracker and zero on the hands. This will cause the hands to not push the torso around and instead have the hips and torso follow the head. Normalize Pulling This checkbox is on by default. When on, you can grab all the effectors of a Power IK rig and move them in world space and the rig will follow the effectors precisely; not over or under shooting. The influence of the effectors on the bones is 'normalized'. But in some cases you do not want the influence of the effectors to act in this manner. You may want to control the influence more precisely by setting \"Normalize Pulling\" off. Now the effector will pull on the body proportional to the Pull Weight multiplied by the inverse distance to the body part. This is especially useful in conjuction with Positive and Negative Pull Factors. Positive/Negative Pull Factors The Positive and Negative Pull Factors give you two 3d vectors to allow scaling the influence of an effector along all three axes in both the positive and negative directions. Negative Pull Factors were used in the \"Prone Mannequin\" example to allow the mannequin to prefer reaching when tilted downwards, and lie flat when tilted upwards. This non-linear behavior is achieved by giving the hands a low negative pull factor in the Z direction (up/down). So the influence they have on the body is greater in the positive Z direction and less in the negative Z. Rotate Bone Rotate Bone is checked off by default. When off, the bone will simply inherit the rotation of it's parent. When on, the bone matches the rotation of the effector. Both are useful depending on the situation. Rotate Limb Rotate Limb is off by default. When on, the effector rotation will be smoothly distributed up the limb. This is useful for spines and look-at behaviors. Rotate Limb is demonstrated on the hanging snake demo in the Unreal examples project. Alpha This value ranges from 0 to 1 and set to 1 by default. The Alpha value blends the influence of this effector on/off. This can be easier than blending the target transforms. For example, if you want to animate a character opening a door and set the effector position to the door knob, you can leave the effector position at the door knob and blend the alpha value on and off for the duration of the reach animation. This is easier than blending the target position.","title":"Effector Settings"},{"location":"unreal/effector_settings/#effectors","text":"","title":"Effectors"},{"location":"unreal/effector_settings/#what-is-a-power-ik-effector","text":"Effectors are how you tell the solver what bone of the skeleton you want to pull, and where you want it to go. Each effector is associated with a single bone in the skeleton and supplies a position and rotation for that bone to reach towards. If you only add 1 effector, it will pull your entire skeleton as though your skeleton were parented to it. Once you have multiple effectors, the solver is able to do interesting work by creating a pose that reaches both effectors simultaneously. For example, by adding an effector to both feet of an ogre, you can pull 1 foot upwards while leaving the other foot on the ground. The hips of the ogre will translate and rotate to help the overall skeleton reach this desired goal.","title":"What is a Power IK Effector?"},{"location":"unreal/effector_settings/#bone-name","text":"This is the name of the bone you want this effector to affect. The name in this field must match the name in the skeleton precisely. Bones cannot be affected by more than 1 effector.","title":"Bone Name"},{"location":"unreal/effector_settings/#position-and-rotation-space","text":"The Position (Vector) and Rotation (Rotator) inputs are both considered to be in 1 of three spaces: Relative to Input Pose : interprets inputs as offsets relative to the affected bone in the pose that is passed as input. This is the default space. World Space : interprets inputs as world space. Component Space : interprets inputs as being relative to the root of the Skeletal Mesh. By default, the space of the effector is Relative to Input Pose with zero position and rotation values. This is essentially telling the solver to not modify the input pose (ie do nothing). All three spaces are useful in different scenarios. But the most common is Relative to Input Pose . This can be used to nudge the skeleton from it\u2019s animated position. For example, by taking a walking animation and pulling the feel outwards and the hips down you can turn a walk into a crouch-walk.","title":"Position and Rotation Space"},{"location":"unreal/effector_settings/#pull-weight","text":"The Pull Weight of an effector determines how much influence the effector has over the whole body relative to other effectors . If all the Pull Weight values are the same, they all have the same relative influence on the skeleton. This is regardless of their absolute values. In cases where you want simple reaching behavior, leaving all the Pull Weights set to 1.0 will split the influence of the effectors evenly. Power IK weights the unaffected parts of the skeleton based on distance (along the skeleton) to your effectors. So you should get decent influence distribution by default. Adjusting Pull Weights is sometimes necessary in situations where you need one part of the body to dominate the pose. For example, to setup a 3-point VR tracking solver, you would want 100% of the weight on the head tracker and zero on the hands. This will cause the hands to not push the torso around and instead have the hips and torso follow the head.","title":"Pull Weight"},{"location":"unreal/effector_settings/#normalize-pulling","text":"This checkbox is on by default. When on, you can grab all the effectors of a Power IK rig and move them in world space and the rig will follow the effectors precisely; not over or under shooting. The influence of the effectors on the bones is 'normalized'. But in some cases you do not want the influence of the effectors to act in this manner. You may want to control the influence more precisely by setting \"Normalize Pulling\" off. Now the effector will pull on the body proportional to the Pull Weight multiplied by the inverse distance to the body part. This is especially useful in conjuction with Positive and Negative Pull Factors.","title":"Normalize Pulling"},{"location":"unreal/effector_settings/#positivenegative-pull-factors","text":"The Positive and Negative Pull Factors give you two 3d vectors to allow scaling the influence of an effector along all three axes in both the positive and negative directions. Negative Pull Factors were used in the \"Prone Mannequin\" example to allow the mannequin to prefer reaching when tilted downwards, and lie flat when tilted upwards. This non-linear behavior is achieved by giving the hands a low negative pull factor in the Z direction (up/down). So the influence they have on the body is greater in the positive Z direction and less in the negative Z.","title":"Positive/Negative Pull Factors"},{"location":"unreal/effector_settings/#rotate-bone","text":"Rotate Bone is checked off by default. When off, the bone will simply inherit the rotation of it's parent. When on, the bone matches the rotation of the effector. Both are useful depending on the situation.","title":"Rotate Bone"},{"location":"unreal/effector_settings/#rotate-limb","text":"Rotate Limb is off by default. When on, the effector rotation will be smoothly distributed up the limb. This is useful for spines and look-at behaviors. Rotate Limb is demonstrated on the hanging snake demo in the Unreal examples project.","title":"Rotate Limb"},{"location":"unreal/effector_settings/#alpha","text":"This value ranges from 0 to 1 and set to 1 by default. The Alpha value blends the influence of this effector on/off. This can be easier than blending the target transforms. For example, if you want to animate a character opening a door and set the effector position to the door knob, you can leave the effector position at the door knob and blend the alpha value on and off for the duration of the reach animation. This is easier than blending the target position.","title":"Alpha"},{"location":"unreal/effector_smoothing/","text":"Effector Smoothing Power IK comes with built-in temporal smoothing to help reduce pops and jitters in fast moving effector inputs. You can apply your own smoothing to the inputs to Power IK effectors, but the built-in smoothing has some advantages: does not introduce non-linear accelerations where there are non in the input clamps positions and rotations to within a threshold distance / angle To enable Effector Smoothing: Select an Effector node in the Animation Graph Drag off the Smoothing pin to create a PowerIKSmoothing struct Toggle the settings as desired. Smoothing Settings Smooth Position Over Time : bool, if True the position of the effector will be smoothed over time. Max Position Speed : this is the maximum speed, in centimeters per second, that the effector is allowed to move. If an input is provided that moves the effector faster than this speed, it will be clamped. Max Position Distance : this is the maximum distance, in centimeters, that the effector will be allowed to lag behind the input position. This limits the error that can be introduced from position smoothing. And similarly for smoothing rotations: Smooth Rotation Over Time : bool, if True the rotation of the effector will be smoothed over time. Max Degrees Speed : this is the maximum speed, in degrees per second, that the effector is allowed to rotate. If an input is provided that rotates the effector faster than this speed, it will be clamped. Max Degrees Distance : this is the maximum angle, in degrees, that the effector will be allowed to lag behind the input rotation. This limits the error that can be introduced from rotation smoothing. Global Smoothing You can globally adjust all the smoothing settings on the solver node itself. The Smoothing Max Speed Multiplier and Smoothing Max Distance Multiplier are set to 1.0 by default. These values are multplied by the Effector settings to arrive at the final smoothing value.","title":"Effector Smoothing"},{"location":"unreal/effector_smoothing/#effector-smoothing","text":"Power IK comes with built-in temporal smoothing to help reduce pops and jitters in fast moving effector inputs. You can apply your own smoothing to the inputs to Power IK effectors, but the built-in smoothing has some advantages: does not introduce non-linear accelerations where there are non in the input clamps positions and rotations to within a threshold distance / angle To enable Effector Smoothing: Select an Effector node in the Animation Graph Drag off the Smoothing pin to create a PowerIKSmoothing struct Toggle the settings as desired.","title":"Effector Smoothing"},{"location":"unreal/effector_smoothing/#smoothing-settings","text":"Smooth Position Over Time : bool, if True the position of the effector will be smoothed over time. Max Position Speed : this is the maximum speed, in centimeters per second, that the effector is allowed to move. If an input is provided that moves the effector faster than this speed, it will be clamped. Max Position Distance : this is the maximum distance, in centimeters, that the effector will be allowed to lag behind the input position. This limits the error that can be introduced from position smoothing. And similarly for smoothing rotations: Smooth Rotation Over Time : bool, if True the rotation of the effector will be smoothed over time. Max Degrees Speed : this is the maximum speed, in degrees per second, that the effector is allowed to rotate. If an input is provided that rotates the effector faster than this speed, it will be clamped. Max Degrees Distance : this is the maximum angle, in degrees, that the effector will be allowed to lag behind the input rotation. This limits the error that can be introduced from rotation smoothing.","title":"Smoothing Settings"},{"location":"unreal/effector_smoothing/#global-smoothing","text":"You can globally adjust all the smoothing settings on the solver node itself. The Smoothing Max Speed Multiplier and Smoothing Max Distance Multiplier are set to 1.0 by default. These values are multplied by the Effector settings to arrive at the final smoothing value.","title":"Global Smoothing"},{"location":"unreal/getting_started_unreal/","text":"Getting the Power IK Unreal Plugin The Power IK Unreal Plugin can be purchased and installed through the Unreal Marketplace. Power IK Unreal Plugin is currently available only for Unreal 4.24 on Windows 64 bit. If you require a different version for a different platform, please contact support@poweranimated.com. Installation The fastest way to get started with Power IK is to purchase it from the Unreal Marketplace and use the Epic Games launcher to install it directly into your engine. To install it manually, follow these steps: Download and unzip the PowerIK plugin Copy the \\PowerIK directory to your project plugins folder: C:\\UnrealProjects\\MyProject\\Plugins Right click on your .uproject file and select Generate Visual Studio project files Build and launch the project as normal.. Note: If you encounter an error when starting Unreal after installing Power IK, please check that you have the Visual Studio Prerequisites installed for Unreal Engine. Missing dll errors (VCRUNTIME140_1.dll for example) are usually resolved by installing the Visual C++ Runtime . Quick Start To use Power IK, you need a Skeletal Mesh and an Animation Blueprint. This tutorial uses the Dino included in the Demo project. Right-click in the Content Browser to create an Animation Blueprint . Associate it with the Dino skeleton and name it ABP_Dino_Tutorial . Open the AnimGraph, right-click and create a Power IK Solver node. Set the Character Root to the top joint in your creature. Usually \u201chips\u201d or \u201cpelvis\u201d. For the Dino we use \u201cpelvis\u201d. This is not usually the absolute root of the Skeleton, but the top node in the creature\u2019s anatomy (the one that translates). Select the Power IK Solver node and in the details panel, click the \u201c+\u201d icon twice to make two Effectors. Right-click on the node and select Refresh Nodes to see the input pins for the Solver effectors. Click and drag one of the effector pins and select Make PowerIKEffector. Repeat for the second effector pin. Set the Bone Name field to the bone you want to touch the effector. For the Dino, we will grab both his feet: \u201cheel_l\u201d and \u201cheel_r\u201d. Connect the solver output to the Output Pose. Compile the anim blueprint. Then select the Power IK Solver node and observe in the viewport that both feet have yellow diamonds on them. These are the effectors. Open the \u201cheel_l\u201d Effector node and set the translation to 0, 0, 50. Then compile and observe new Effector location in the viewport: Drag the Skeletal Mesh asset into a level. In the details panel, set the Anim Class to the animation blueprint asset we just created: Now click Play. Observe that the left foot is reaching up, while the right foot remains planted on the ground. The pelvis, being free of any effectors, will automatically translate and rotate to help the feet reach the targets. Congratulations! Power IK is now setup and working. From here, you are ready to drive the positions and rotations of the effectors through blueprint. These transforms can come from any source. Sophisticated procedural animation systems can be built ontop of Power IK. For testing/debug purposes, you can create a PowerIK Interactive Rig which allows you to interactively pull your effector positions with the mouse.","title":"Getting Started"},{"location":"unreal/getting_started_unreal/#getting-the-power-ik-unreal-plugin","text":"The Power IK Unreal Plugin can be purchased and installed through the Unreal Marketplace. Power IK Unreal Plugin is currently available only for Unreal 4.24 on Windows 64 bit. If you require a different version for a different platform, please contact support@poweranimated.com.","title":"Getting the Power IK Unreal Plugin"},{"location":"unreal/getting_started_unreal/#installation","text":"The fastest way to get started with Power IK is to purchase it from the Unreal Marketplace and use the Epic Games launcher to install it directly into your engine. To install it manually, follow these steps: Download and unzip the PowerIK plugin Copy the \\PowerIK directory to your project plugins folder: C:\\UnrealProjects\\MyProject\\Plugins Right click on your .uproject file and select Generate Visual Studio project files Build and launch the project as normal.. Note: If you encounter an error when starting Unreal after installing Power IK, please check that you have the Visual Studio Prerequisites installed for Unreal Engine. Missing dll errors (VCRUNTIME140_1.dll for example) are usually resolved by installing the Visual C++ Runtime .","title":"Installation"},{"location":"unreal/getting_started_unreal/#quick-start","text":"To use Power IK, you need a Skeletal Mesh and an Animation Blueprint. This tutorial uses the Dino included in the Demo project. Right-click in the Content Browser to create an Animation Blueprint . Associate it with the Dino skeleton and name it ABP_Dino_Tutorial . Open the AnimGraph, right-click and create a Power IK Solver node. Set the Character Root to the top joint in your creature. Usually \u201chips\u201d or \u201cpelvis\u201d. For the Dino we use \u201cpelvis\u201d. This is not usually the absolute root of the Skeleton, but the top node in the creature\u2019s anatomy (the one that translates). Select the Power IK Solver node and in the details panel, click the \u201c+\u201d icon twice to make two Effectors. Right-click on the node and select Refresh Nodes to see the input pins for the Solver effectors. Click and drag one of the effector pins and select Make PowerIKEffector. Repeat for the second effector pin. Set the Bone Name field to the bone you want to touch the effector. For the Dino, we will grab both his feet: \u201cheel_l\u201d and \u201cheel_r\u201d. Connect the solver output to the Output Pose. Compile the anim blueprint. Then select the Power IK Solver node and observe in the viewport that both feet have yellow diamonds on them. These are the effectors. Open the \u201cheel_l\u201d Effector node and set the translation to 0, 0, 50. Then compile and observe new Effector location in the viewport: Drag the Skeletal Mesh asset into a level. In the details panel, set the Anim Class to the animation blueprint asset we just created: Now click Play. Observe that the left foot is reaching up, while the right foot remains planted on the ground. The pelvis, being free of any effectors, will automatically translate and rotate to help the feet reach the targets. Congratulations! Power IK is now setup and working. From here, you are ready to drive the positions and rotations of the effectors through blueprint. These transforms can come from any source. Sophisticated procedural animation systems can be built ontop of Power IK. For testing/debug purposes, you can create a PowerIK Interactive Rig which allows you to interactively pull your effector positions with the mouse.","title":"Quick Start"},{"location":"unreal/grounding/","text":"Grounding Power IK comes with built in grounding ability to contour your creatures to uneven terrain. Note: This feature is in active development. Procedural leaning and stride adjustment will be available in a future release. The current version is great for creatures with 4 or more limbs, but you will not get proper heel placement in bipeds. How it Works Effector's have an IsGrounded flag that causes Power IK to stick the effector to the ground. This is useful for animating feet on uneven terrain. It helps to understand the basic algorithm for ground alignment: For each effector that \u201cIs Grounded\u201d: Calculate effector location in world space Cast a ray from this location If ray hits collider: Smoothly move the effector towards hit point Run solver using new effector locations As you can see, because it is based on raycasts, you have to make sure that your collision filtering and level collision is setup to support good ground IK. How to Setup Grounding First Setup a Solver with Grounded Effectors Create a Power IK Solver node with one effector for each \u201cfoot\u201d to be grounded. Set Bone Name to the name of the foot bone. Check IsGrounded on. Set Pull Weight to 0.0 Set Normalize Pulling to off. At this point, Power IK will stick the feet to the ground. Turning the Pull Weight off prevents the effector from yanking the body around while animating. Though for creatures with many limbs (like spiders), it may actually be nice to have the limbs pulling the body. For bipeds though, it is typically best to turn Pulling off and let the slope alignment settings move the hips for you. Note: You will likely want to utilize Effector Smoothing when using IsGrounded. Otherwise legs can seemingly \"pop\" instantly ontop of obstacles. Now Tune the Slope Settings Select the solver node and in the details pane find the Ground Slope section. Tune these settings to achieve the desired ground alignment behavior. See the Ground Slope Settings section for details on what each of these parameters do. Interactive Tuning You can adjust the slope settings interactively while playing in editor. Simply open the Animation Blueprint, select your character and adjust the slope settings. You must Compile the animation blueprint between parameter adjustements to see the effect while playing in editor. It can be useful to place a cube underneath your character that you can rotate freely as you tune slope settings interactively. Collision Settings All the Grounding settings are found by selecting the solver node and opening the details panel: Ground Plane Bone : the name of the bone that represents the \u201cground plane\u201d in your animation. Typically this is just the root bone, but you can use a separate bone if you want. The height of the effector relative to this plane is always maintained. So if the animation pulls the characters foot 10cm above the ground plane, then the foot will be 10cm above the ray cast hit location. Collision Channel : this is the level collision channel that the rays are collided against. Make sure that the level is setup with collision on this channel for the character to collide with. Trace Complex: whether to trace against Complex or Simple collision geometry. Complex is usually preferred, though slightly more expensive. Ray Cast Up : the distance in centimeters to cast upwards looking for terrain to stand on. Ray Cast Down : the distance in centimeters to cast downwards looking for terrain to stand on. Slope Alignment Settings Global Settings Vec3 StrideDirection: Normalized vector that describes the direction of travel. This vector points in the forward facing direction of your character and usually remains constant. MaxGroundAngle: Maximum angle relative to gravity vector to apply leaning and stride scaling. Stride Scaling These settings scale the stride of the foot effectors. Essentially making the character take longer or shorter steps. ScaleStride bool: If true, stride of IsGrounded effectors will be scaled in Stride Direction. UphillStrideScale float: Amount to scale stride when going uphill. Range is 0-1. Default 0.4. DownhillStrideScale float: Amount to scale stride when going downhill. Range is 0-1. Default 0.2. SidehillStrideScale float: Amount to scale stride when on a side-hill. Range is 0-1. Default 1.0. SidehillPushOuterFeet float: Amount (in centimeters) to push outside feet outwards on sidehills. Default is 20.0. SidehillPushInnerFeet float: Amount (in centimeters) to push inside feet outwards on sidehills. Default is 10.0. Leaning These settings rotate the spine of the character to lean into or away from a slope. Lean bool: If True, character root bone is rotated in opposite direction of ground normal. UphillLean float: Amount to lean forward when going uphill. Range is 0-1. Default 0.3. DownhillLean float: Amount to lean backward when going downhill. Range is 0-1. Default 0.5. SidehillLean float: Amount to lean sideways into side-hills. Range is 0-1. Default 0.0. Counter Leaning These settings are designed to allow the head of the character to counteract the spine leaning adjustments. This prevents characters from looking straight down when leaning into an up hill, or straight up when leaning back on a downhill. CounterLean bool: If True, will counter lean CounterLeanBone. Usually this is the head. CounterLeanBoneName Name: Name of base of counter lean bone. Usually this is the base Head bone. UphillCounterLean float: Amount to counter lean backward when going uphill. Range is 0-1. Default 0.8. DownhillCounterLean float: Amount to counter lean backward when going downhill. Range is 0-1. Default 1.0. SidehillCounterLean float: Amount to counter lean sideways into side-hills. Range is 0-1. Default 0.0. Root Offset These settings let you offset the position of the root bone above the foot effectors. It's useful to be able to push the root forward/back and up and down in reaction to the slope. MoveRoot bool: If True, character root bone position is gradually pushed vertically and horizontally. UphillVertOffset float: Amount (in centimeters) to push the character root up/down when going UP hill. Default 10.0. UphillHorizOffset float: Amount (in centimeters) to push the character root forward/back when going UP hill. Default -20.0. DownhillVertOffset float: Amount (in centimeters) to push the character root up/down when going DOWN hill. Default 10.0. DownhillHorizOffset float: Amount (in centimeters) to push the character root forward/back when going DOWN hill. Default 20.0. SidehillVertOffset float: Amount (in centimeters) to push the character root up/down when on a SIDE hill. Default -10.0. SidehillHorizOffset float: Amount (in centimeters) to push the character root forward/back when on a SIDE hill. Default -10.0. Foot Rotation It is useful to be able to control the rotation of the foot pitch and roll independently. Creatures usually orient the pitch of their foot to the ground, but only slightly roll the foot to the ground. RotateFootToGround bool: If True, feet are oriented to ground normal. PitchFootAmount float: Amount to pitch foot to orient to up/down hills. Range is 0-1. Default 1.0. RollFootAmount float: Amount to roll foot to orient to sidehills. Range is 0-1. Default 0.6.","title":"Grounding"},{"location":"unreal/grounding/#grounding","text":"Power IK comes with built in grounding ability to contour your creatures to uneven terrain. Note: This feature is in active development. Procedural leaning and stride adjustment will be available in a future release. The current version is great for creatures with 4 or more limbs, but you will not get proper heel placement in bipeds.","title":"Grounding"},{"location":"unreal/grounding/#how-it-works","text":"Effector's have an IsGrounded flag that causes Power IK to stick the effector to the ground. This is useful for animating feet on uneven terrain. It helps to understand the basic algorithm for ground alignment: For each effector that \u201cIs Grounded\u201d: Calculate effector location in world space Cast a ray from this location If ray hits collider: Smoothly move the effector towards hit point Run solver using new effector locations As you can see, because it is based on raycasts, you have to make sure that your collision filtering and level collision is setup to support good ground IK.","title":"How it Works"},{"location":"unreal/grounding/#how-to-setup-grounding","text":"","title":"How to Setup Grounding"},{"location":"unreal/grounding/#first-setup-a-solver-with-grounded-effectors","text":"Create a Power IK Solver node with one effector for each \u201cfoot\u201d to be grounded. Set Bone Name to the name of the foot bone. Check IsGrounded on. Set Pull Weight to 0.0 Set Normalize Pulling to off. At this point, Power IK will stick the feet to the ground. Turning the Pull Weight off prevents the effector from yanking the body around while animating. Though for creatures with many limbs (like spiders), it may actually be nice to have the limbs pulling the body. For bipeds though, it is typically best to turn Pulling off and let the slope alignment settings move the hips for you. Note: You will likely want to utilize Effector Smoothing when using IsGrounded. Otherwise legs can seemingly \"pop\" instantly ontop of obstacles.","title":"First Setup a Solver with Grounded Effectors"},{"location":"unreal/grounding/#now-tune-the-slope-settings","text":"Select the solver node and in the details pane find the Ground Slope section. Tune these settings to achieve the desired ground alignment behavior. See the Ground Slope Settings section for details on what each of these parameters do.","title":"Now Tune the Slope Settings"},{"location":"unreal/grounding/#interactive-tuning","text":"You can adjust the slope settings interactively while playing in editor. Simply open the Animation Blueprint, select your character and adjust the slope settings. You must Compile the animation blueprint between parameter adjustements to see the effect while playing in editor. It can be useful to place a cube underneath your character that you can rotate freely as you tune slope settings interactively.","title":"Interactive Tuning"},{"location":"unreal/grounding/#collision-settings","text":"All the Grounding settings are found by selecting the solver node and opening the details panel: Ground Plane Bone : the name of the bone that represents the \u201cground plane\u201d in your animation. Typically this is just the root bone, but you can use a separate bone if you want. The height of the effector relative to this plane is always maintained. So if the animation pulls the characters foot 10cm above the ground plane, then the foot will be 10cm above the ray cast hit location. Collision Channel : this is the level collision channel that the rays are collided against. Make sure that the level is setup with collision on this channel for the character to collide with. Trace Complex: whether to trace against Complex or Simple collision geometry. Complex is usually preferred, though slightly more expensive. Ray Cast Up : the distance in centimeters to cast upwards looking for terrain to stand on. Ray Cast Down : the distance in centimeters to cast downwards looking for terrain to stand on.","title":"Collision Settings"},{"location":"unreal/grounding/#slope-alignment-settings","text":"","title":"Slope Alignment Settings"},{"location":"unreal/grounding/#global-settings","text":"Vec3 StrideDirection: Normalized vector that describes the direction of travel. This vector points in the forward facing direction of your character and usually remains constant. MaxGroundAngle: Maximum angle relative to gravity vector to apply leaning and stride scaling.","title":"Global Settings"},{"location":"unreal/grounding/#stride-scaling","text":"These settings scale the stride of the foot effectors. Essentially making the character take longer or shorter steps. ScaleStride bool: If true, stride of IsGrounded effectors will be scaled in Stride Direction. UphillStrideScale float: Amount to scale stride when going uphill. Range is 0-1. Default 0.4. DownhillStrideScale float: Amount to scale stride when going downhill. Range is 0-1. Default 0.2. SidehillStrideScale float: Amount to scale stride when on a side-hill. Range is 0-1. Default 1.0. SidehillPushOuterFeet float: Amount (in centimeters) to push outside feet outwards on sidehills. Default is 20.0. SidehillPushInnerFeet float: Amount (in centimeters) to push inside feet outwards on sidehills. Default is 10.0.","title":"Stride Scaling"},{"location":"unreal/grounding/#leaning","text":"These settings rotate the spine of the character to lean into or away from a slope. Lean bool: If True, character root bone is rotated in opposite direction of ground normal. UphillLean float: Amount to lean forward when going uphill. Range is 0-1. Default 0.3. DownhillLean float: Amount to lean backward when going downhill. Range is 0-1. Default 0.5. SidehillLean float: Amount to lean sideways into side-hills. Range is 0-1. Default 0.0.","title":"Leaning"},{"location":"unreal/grounding/#counter-leaning","text":"These settings are designed to allow the head of the character to counteract the spine leaning adjustments. This prevents characters from looking straight down when leaning into an up hill, or straight up when leaning back on a downhill. CounterLean bool: If True, will counter lean CounterLeanBone. Usually this is the head. CounterLeanBoneName Name: Name of base of counter lean bone. Usually this is the base Head bone. UphillCounterLean float: Amount to counter lean backward when going uphill. Range is 0-1. Default 0.8. DownhillCounterLean float: Amount to counter lean backward when going downhill. Range is 0-1. Default 1.0. SidehillCounterLean float: Amount to counter lean sideways into side-hills. Range is 0-1. Default 0.0.","title":"Counter Leaning"},{"location":"unreal/grounding/#root-offset","text":"These settings let you offset the position of the root bone above the foot effectors. It's useful to be able to push the root forward/back and up and down in reaction to the slope. MoveRoot bool: If True, character root bone position is gradually pushed vertically and horizontally. UphillVertOffset float: Amount (in centimeters) to push the character root up/down when going UP hill. Default 10.0. UphillHorizOffset float: Amount (in centimeters) to push the character root forward/back when going UP hill. Default -20.0. DownhillVertOffset float: Amount (in centimeters) to push the character root up/down when going DOWN hill. Default 10.0. DownhillHorizOffset float: Amount (in centimeters) to push the character root forward/back when going DOWN hill. Default 20.0. SidehillVertOffset float: Amount (in centimeters) to push the character root up/down when on a SIDE hill. Default -10.0. SidehillHorizOffset float: Amount (in centimeters) to push the character root forward/back when on a SIDE hill. Default -10.0.","title":"Root Offset"},{"location":"unreal/grounding/#foot-rotation","text":"It is useful to be able to control the rotation of the foot pitch and roll independently. Creatures usually orient the pitch of their foot to the ground, but only slightly roll the foot to the ground. RotateFootToGround bool: If True, feet are oriented to ground normal. PitchFootAmount float: Amount to pitch foot to orient to up/down hills. Range is 0-1. Default 1.0. RollFootAmount float: Amount to roll foot to orient to sidehills. Range is 0-1. Default 0.6.","title":"Foot Rotation"},{"location":"unreal/interactive_rig/","text":"Power IK Interactive Rig It is sometimes helpful to have an interactive rig with effectors that you can push and pull with your mouse. This is useful for testing your skeletons and poses with Power IK to see how they will be affected while prototyping a new behavior. Power IK Rig Actor Component The Power IK plugin comes with an Actor Component that greatly simplifies the process of setting up an interactive rig. The Power IK Rig Actor Component creates a \u201cgizmo\u201d static mesh (tri-colored arrows showing the transform position and rotation) for each effector. When you \u201cEject\u201d, while playing in-editor, the gizmos become selectable with the mouse. You can then translate and rotate them to interact with the rig. How to Setup a Rig Component First we setup a blank actor class with just a Skeletal Mesh and a Power IK Rig component. Create a new Blueprint Class, select Actor as the Parent Class. Open the new blueprint, click Add Component and select Skeletal Mesh . Click Add Component and select PowerIKRig Select the Power IK Rig component, click the \u201c+\u201d icon to add Rig Effectors . Type in the names of the bones you want to affect for each effector. For the Dino, we would use \u201cheel_l\u201d and \u201cheel_r\u201d to make an interactive rig to move his feet. This concludes the rig component setup. Now you have to setup an animation blueprint that gets a reference to the Power IK rig component, and uses the rig\u2019s effectors to drive the Power IK solver. Create an Animation Blueprint asset for your Skeletal Mesh. Add a variable of type Power IK Rig . Name it \"Rig\". In the event graph, get a reference to the Power IK Rig Component on Begin Play using the supplied function Get Power IK Rig from ABP() . Drag the PowerIK Rig component reference into your Anim Graph. Drag a pin off the rig to call the function Get Power IK Rig Effector() . Set the Bone Name on each effector to the same names supplied to the Power IK Rig Component. Connect the effectors to a Power IK Solver node. Connect the input of the solver to a Mesh Space Ref Pose, and the output directly to the Output Pose node. That concludes the Animation Blueprint setup. Now, we need to add this animation blueprint and skeletal mesh to our actor blueprint. Open the actor blueprint class and select the Skeletal Mesh component. Set the Anim Class to the Animation Blueprint asset we just created. Set the Skeletal Mesh to the appropriate Skeletal Mesh asset. Compile and save the actor blueprint. Drag the actor into a level. Hit Play, then hit Eject. You should see gizmos at the effector locations. Select them with the mouse, hit \u201cW\u201d key to enter move mode and drag your rig interactively! Interactive Rigs at Runtime There is obviously no \"Eject\" button in Shipping builds of Unreal. The Power IK Rig component is meant purely for debugging effector and solver settings. But you could easily replicate the Power IK Rig behavior at runtime if needed, using whatever user input you desire (touch, gesture, VR, etc). The Power IK Rig component drives effector positions in the same way that any procedural system would and in that way it acts as an example of how to create systems that drive Power IK.","title":"Interactive Rig"},{"location":"unreal/interactive_rig/#power-ik-interactive-rig","text":"It is sometimes helpful to have an interactive rig with effectors that you can push and pull with your mouse. This is useful for testing your skeletons and poses with Power IK to see how they will be affected while prototyping a new behavior.","title":"Power IK Interactive Rig"},{"location":"unreal/interactive_rig/#power-ik-rig-actor-component","text":"The Power IK plugin comes with an Actor Component that greatly simplifies the process of setting up an interactive rig. The Power IK Rig Actor Component creates a \u201cgizmo\u201d static mesh (tri-colored arrows showing the transform position and rotation) for each effector. When you \u201cEject\u201d, while playing in-editor, the gizmos become selectable with the mouse. You can then translate and rotate them to interact with the rig.","title":"Power IK Rig Actor Component"},{"location":"unreal/interactive_rig/#how-to-setup-a-rig-component","text":"First we setup a blank actor class with just a Skeletal Mesh and a Power IK Rig component. Create a new Blueprint Class, select Actor as the Parent Class. Open the new blueprint, click Add Component and select Skeletal Mesh . Click Add Component and select PowerIKRig Select the Power IK Rig component, click the \u201c+\u201d icon to add Rig Effectors . Type in the names of the bones you want to affect for each effector. For the Dino, we would use \u201cheel_l\u201d and \u201cheel_r\u201d to make an interactive rig to move his feet. This concludes the rig component setup. Now you have to setup an animation blueprint that gets a reference to the Power IK rig component, and uses the rig\u2019s effectors to drive the Power IK solver. Create an Animation Blueprint asset for your Skeletal Mesh. Add a variable of type Power IK Rig . Name it \"Rig\". In the event graph, get a reference to the Power IK Rig Component on Begin Play using the supplied function Get Power IK Rig from ABP() . Drag the PowerIK Rig component reference into your Anim Graph. Drag a pin off the rig to call the function Get Power IK Rig Effector() . Set the Bone Name on each effector to the same names supplied to the Power IK Rig Component. Connect the effectors to a Power IK Solver node. Connect the input of the solver to a Mesh Space Ref Pose, and the output directly to the Output Pose node. That concludes the Animation Blueprint setup. Now, we need to add this animation blueprint and skeletal mesh to our actor blueprint. Open the actor blueprint class and select the Skeletal Mesh component. Set the Anim Class to the Animation Blueprint asset we just created. Set the Skeletal Mesh to the appropriate Skeletal Mesh asset. Compile and save the actor blueprint. Drag the actor into a level. Hit Play, then hit Eject. You should see gizmos at the effector locations. Select them with the mouse, hit \u201cW\u201d key to enter move mode and drag your rig interactively!","title":"How to Setup a Rig Component"},{"location":"unreal/interactive_rig/#interactive-rigs-at-runtime","text":"There is obviously no \"Eject\" button in Shipping builds of Unreal. The Power IK Rig component is meant purely for debugging effector and solver settings. But you could easily replicate the Power IK Rig behavior at runtime if needed, using whatever user input you desire (touch, gesture, VR, etc). The Power IK Rig component drives effector positions in the same way that any procedural system would and in that way it acts as an example of how to create systems that drive Power IK.","title":"Interactive Rigs at Runtime"},{"location":"unreal/limits/","text":"Limits and Stiffness It is desireable to have control over how much bones in your skeleton can rotate in any given direction. This is an active area of development in Power IK. Joint Limits Note: Angular joint limits are currently in active development and are not yet supported in Power IK. Until joint limits are released, you can achieve a similar result using Bend Directions , which are currently supported. Joint Stiffness Note: Joint stiffness is currently in active development and is currently experimental. As of v1.3, Power IK adds basic support for joint stiffness. You can set joint stiffness to 1.0 to lock that joint so that it does not rotate. Future releases will support \"soft\" stiffness for values between 0 and 1.","title":"Limits and Stiffness"},{"location":"unreal/limits/#limits-and-stiffness","text":"It is desireable to have control over how much bones in your skeleton can rotate in any given direction. This is an active area of development in Power IK.","title":"Limits and Stiffness"},{"location":"unreal/limits/#joint-limits","text":"Note: Angular joint limits are currently in active development and are not yet supported in Power IK. Until joint limits are released, you can achieve a similar result using Bend Directions , which are currently supported.","title":"Joint Limits"},{"location":"unreal/limits/#joint-stiffness","text":"Note: Joint stiffness is currently in active development and is currently experimental. As of v1.3, Power IK adds basic support for joint stiffness. You can set joint stiffness to 1.0 to lock that joint so that it does not rotate. Future releases will support \"soft\" stiffness for values between 0 and 1.","title":"Joint Stiffness"},{"location":"unreal/packaging/","text":"Packaging Your Game Windows In Windows, the Power IK plugin registers a .dll (POWERIK.dll) with Unreal\u2019s build system that is automatically copied into the build folder when packaging Win64 builds. This .dll must be distributed with the final .exe. You should not have to manage this yourself, just be aware that it is required. Linux The Linux build will be coming to the Unreal Marketplace soon. Linux builds will statically compile Power IK into your executable. We do not use dynamic linking on Linux. Other Platforms Power IK is available for all major platforms. Please contact us if you would like to license Power IK for consoles or other platforms.","title":"Packaging"},{"location":"unreal/packaging/#packaging-your-game","text":"","title":"Packaging Your Game"},{"location":"unreal/packaging/#windows","text":"In Windows, the Power IK plugin registers a .dll (POWERIK.dll) with Unreal\u2019s build system that is automatically copied into the build folder when packaging Win64 builds. This .dll must be distributed with the final .exe. You should not have to manage this yourself, just be aware that it is required.","title":"Windows"},{"location":"unreal/packaging/#linux","text":"The Linux build will be coming to the Unreal Marketplace soon. Linux builds will statically compile Power IK into your executable. We do not use dynamic linking on Linux.","title":"Linux"},{"location":"unreal/packaging/#other-platforms","text":"Power IK is available for all major platforms. Please contact us if you would like to license Power IK for consoles or other platforms.","title":"Other Platforms"},{"location":"unreal/procedural_anim/","text":"Bonus Procedural Animation Blueprint Power IK is a generic tool that can be used for a multitude of purposes. We included a bonus set of blueprints to get you started generating procedural animation with Power IK. What is Procedural Animation Procedural animation simply means, \u201canything that isn\u2019t pre-recorded keyframes\u201d. This includes physics, IK and direct bone manipulation. Often these methods are mixed with keyframe animation to achieve dynamic and compelling behaviors that would otherwise be impossible using keyframes alone. Procedural animation is gaining in popularity and it greatly benefits from a full body IK solver. Typical methods attempt to algorithmically generate foot positions, or some high-level goal for the animation, and let IK and physics create the final pose. Using a regular single-chain IK solver, it is difficult to get the full pose to look realistic. Limbs can feel disconnected from each other and the rest of the body (because they are). That\u2019s where a full-body solver like Power IK can help you achieve more natural poses with less effort. With Power IK, you can set foot positions procedurally, and let the solver create a natural pose for the rest of the body. Actor Setup Inside Content/Bonus_ProceduralAnim you will find two blueprints, BP_Leg and BP_LegManager. These blueprints exist solely to generate foot positions which are then fed into Power IK. Add the Legs and Leg Manager to an actor: Add a BP_LegManager actor component to an actor. Add a BP_Leg for each leg of the actor. Position the scene component in the viewport at the location of the hips. Orient the BP_Leg scene component in the actor Viewport so that +X points in the direction you want to ray-cast for foot positions. Set a tag on each BP_Leg component so you can identify it later. Animation Blueprint Setup Now you need to get the foot positions from the BP_Leg components and feed them into Power IK in the animation graph. Get references to the actor components in the animation blueprint: Create 3 variables in the animation blueprint. One BP_LegManager object reference, and two BP_Leg references (or however many legs you have). On Begin Play, we need to get a reference to the Leg Manager component and store it. And do the same for the legs using the included Get Leg Reference function and the tag names that you added to each BP_Leg component. Add two vector-type variables to store the foot positions, and get them from the legs using the Blueprint Update Animation event. Drag these foot position vectors into the animation graph and connect them to the Position of a PowerIK Effector. Set the effector space to World Space. And plug it into a solver. You will of course need your character capsule to actually move if you hope to see the legs walking. The included project has a sample of a random patrol behavior tree which is enough to test procedural walking. See the Dino_Walking sample blueprints for detailed comments on what exactly the BP_Leg and BP_LegManager are doing to generate foot positions procedurally. Tune the Walking Behavior Different sized characters will take larger or smaller steps at different speeds. Or you may want to even modulate a characters walking behavior depending on their state. Each BP_Leg has a Walking Leg settings category with options for adjusting all aspects of the gait behavior: Ray Cast Length : the distance from the BP_Leg scene component that the system will ray-cast to look for a target foot position. Increase this for larger characters to ensure they can reach the ground. Step Height : the maximum height in centimeters the foot is raised off the ground mid-stride. Step Time : the time in seconds it takes to make a step (from unplanting to replanting). Step Distance : the distance in centimeters to step between unplanting and replanting. The Replant Speed Curve and Replant Height Curves can be modified to adjust the ease-in and ease-out of the foot position and height. The curve ranges are normalized from 0 to 1 which represents the time for a complete step (unplant to replant). Get Creative! The procedural walking blueprints are just a small sample of what\u2019s possible with procedural animation when combined with a full-body IK solver like Power IK. Add More Legs : You could extend the BP_LegManager to support multiple sets of legs, where each set of legs is synchronized. This would open it up to support insects and arachnid gaits. Support Running : You could add support for procedural running by creating a mode that allows feet to unplant at the same time, within \u2018tolerance\u2019 ranges. Layer on Physics and Animation : Layer your procedural walking with procedural look-ats, secondary physics and keyframe animation to add believability and style. More Procedural Actions : You could add procedural turn on spot, jumping and even attacks. Power IK unleashes a lot of possibilities for creative expression with Unreal blueprint.","title":"Procedural Animation"},{"location":"unreal/procedural_anim/#bonus-procedural-animation-blueprint","text":"Power IK is a generic tool that can be used for a multitude of purposes. We included a bonus set of blueprints to get you started generating procedural animation with Power IK.","title":"Bonus Procedural Animation Blueprint"},{"location":"unreal/procedural_anim/#what-is-procedural-animation","text":"Procedural animation simply means, \u201canything that isn\u2019t pre-recorded keyframes\u201d. This includes physics, IK and direct bone manipulation. Often these methods are mixed with keyframe animation to achieve dynamic and compelling behaviors that would otherwise be impossible using keyframes alone. Procedural animation is gaining in popularity and it greatly benefits from a full body IK solver. Typical methods attempt to algorithmically generate foot positions, or some high-level goal for the animation, and let IK and physics create the final pose. Using a regular single-chain IK solver, it is difficult to get the full pose to look realistic. Limbs can feel disconnected from each other and the rest of the body (because they are). That\u2019s where a full-body solver like Power IK can help you achieve more natural poses with less effort. With Power IK, you can set foot positions procedurally, and let the solver create a natural pose for the rest of the body.","title":"What is Procedural Animation"},{"location":"unreal/procedural_anim/#actor-setup","text":"Inside Content/Bonus_ProceduralAnim you will find two blueprints, BP_Leg and BP_LegManager. These blueprints exist solely to generate foot positions which are then fed into Power IK. Add the Legs and Leg Manager to an actor: Add a BP_LegManager actor component to an actor. Add a BP_Leg for each leg of the actor. Position the scene component in the viewport at the location of the hips. Orient the BP_Leg scene component in the actor Viewport so that +X points in the direction you want to ray-cast for foot positions. Set a tag on each BP_Leg component so you can identify it later.","title":"Actor Setup"},{"location":"unreal/procedural_anim/#animation-blueprint-setup","text":"Now you need to get the foot positions from the BP_Leg components and feed them into Power IK in the animation graph. Get references to the actor components in the animation blueprint: Create 3 variables in the animation blueprint. One BP_LegManager object reference, and two BP_Leg references (or however many legs you have). On Begin Play, we need to get a reference to the Leg Manager component and store it. And do the same for the legs using the included Get Leg Reference function and the tag names that you added to each BP_Leg component. Add two vector-type variables to store the foot positions, and get them from the legs using the Blueprint Update Animation event. Drag these foot position vectors into the animation graph and connect them to the Position of a PowerIK Effector. Set the effector space to World Space. And plug it into a solver. You will of course need your character capsule to actually move if you hope to see the legs walking. The included project has a sample of a random patrol behavior tree which is enough to test procedural walking. See the Dino_Walking sample blueprints for detailed comments on what exactly the BP_Leg and BP_LegManager are doing to generate foot positions procedurally.","title":"Animation Blueprint Setup"},{"location":"unreal/procedural_anim/#tune-the-walking-behavior","text":"Different sized characters will take larger or smaller steps at different speeds. Or you may want to even modulate a characters walking behavior depending on their state. Each BP_Leg has a Walking Leg settings category with options for adjusting all aspects of the gait behavior: Ray Cast Length : the distance from the BP_Leg scene component that the system will ray-cast to look for a target foot position. Increase this for larger characters to ensure they can reach the ground. Step Height : the maximum height in centimeters the foot is raised off the ground mid-stride. Step Time : the time in seconds it takes to make a step (from unplanting to replanting). Step Distance : the distance in centimeters to step between unplanting and replanting. The Replant Speed Curve and Replant Height Curves can be modified to adjust the ease-in and ease-out of the foot position and height. The curve ranges are normalized from 0 to 1 which represents the time for a complete step (unplant to replant).","title":"Tune the Walking Behavior"},{"location":"unreal/procedural_anim/#get-creative","text":"The procedural walking blueprints are just a small sample of what\u2019s possible with procedural animation when combined with a full-body IK solver like Power IK. Add More Legs : You could extend the BP_LegManager to support multiple sets of legs, where each set of legs is synchronized. This would open it up to support insects and arachnid gaits. Support Running : You could add support for procedural running by creating a mode that allows feet to unplant at the same time, within \u2018tolerance\u2019 ranges. Layer on Physics and Animation : Layer your procedural walking with procedural look-ats, secondary physics and keyframe animation to add believability and style. More Procedural Actions : You could add procedural turn on spot, jumping and even attacks. Power IK unleashes a lot of possibilities for creative expression with Unreal blueprint.","title":"Get Creative!"},{"location":"unreal/root_rotation/","text":"Root Rotation Multiplier The Power IK solver has an attribute called Root Rotation Multiplier . The default value is 1.0 which causes the root bone to rotate a small amount in reaction to the movement of the effectors. In some cases, it may be preferrable to add more or less rotation on the root bone. For human characters, the pelvis can be quite loose and a value of 3.0 or more may be needed to get natural pelvis rotation when the feet and torso are being pulled.","title":"Root Rotation"},{"location":"unreal/root_rotation/#root-rotation-multiplier","text":"The Power IK solver has an attribute called Root Rotation Multiplier . The default value is 1.0 which causes the root bone to rotate a small amount in reaction to the movement of the effectors. In some cases, it may be preferrable to add more or less rotation on the root bone. For human characters, the pelvis can be quite loose and a value of 3.0 or more may be needed to get natural pelvis rotation when the feet and torso are being pulled.","title":"Root Rotation Multiplier"},{"location":"unreal/solver_bones/","text":"Solver Bones The Power IK solver itself requires just 2 bones to be specified by the user. Note: Power IK does not support changing these bone names at run-time. They must be set prior to the first call to Solve(). Character Root Set the Character Root to the top-most joint that is part of your character's body. This is usually not the actual top-node of the skeleton. This defaults to \"pelvis\" though some rigs call it \"hips\" or \"body\". Any bones below the Character Root will potentially be affected by Power IK. Any bones above the Character Root are completely ignored by Power IK and will pass through the solver unaffected. Ground Plane Bone Set this to the bone in your skeleton that is located at the origin of your character. This defaults to \"root\", but some rigs call it \"world\" or \"origin\". This bone defines the ground plane of the input animation and is only used when the solver needs a reference to the ground location. The Ground Plane Bone is required even if none of the effectors are grounded.","title":"Solver Bones"},{"location":"unreal/solver_bones/#solver-bones","text":"The Power IK solver itself requires just 2 bones to be specified by the user. Note: Power IK does not support changing these bone names at run-time. They must be set prior to the first call to Solve().","title":"Solver Bones"},{"location":"unreal/solver_bones/#character-root","text":"Set the Character Root to the top-most joint that is part of your character's body. This is usually not the actual top-node of the skeleton. This defaults to \"pelvis\" though some rigs call it \"hips\" or \"body\". Any bones below the Character Root will potentially be affected by Power IK. Any bones above the Character Root are completely ignored by Power IK and will pass through the solver unaffected.","title":"Character Root"},{"location":"unreal/solver_bones/#ground-plane-bone","text":"Set this to the bone in your skeleton that is located at the origin of your character. This defaults to \"root\", but some rigs call it \"world\" or \"origin\". This bone defines the ground plane of the input animation and is only used when the solver needs a reference to the ground location. The Ground Plane Bone is required even if none of the effectors are grounded.","title":"Ground Plane Bone"},{"location":"unreal/solver_performance/","text":"Solver Performance Power IK uses a proprietary iterative solver that can generate nice looking poses with remarkably few iterations compared to standard IK solutions. That said, you should be aware of the performance implications of using Power IK. Especially on resource constrained devices like mobile CPUs. Iterations The primary means of controlling the cost of Power IK is to adjust the number of Squash and Stretch iterations. Both default to 6 iterations each. It is unlikely that you will need more iterations than this. Though depending on the complexity of your skeleton, you may be able to get away with less. Max Squash Iterations : This is the number of iterations that the solver computes when squashing a limb. Typically, this can be left at the default. Though higher iterations may help with long complex limbs that have many bones . Max Stretch Iterations : Set this as low as you can before your effectors stop reaching their targets, or if your chain forms kinks or wobbles. A value of 6 is typically good enough even for complex chains. Note: these settings can affect performance. You should always reduce the iterations as much as you can while maintaining good results. Solver Alpha Power IK can be smoothly blended on/off with the Solver Alpha input. This value ranges from 0-1. At zero, Power IK will shut off completely . So this can be used as a simple way of disabling the solver completely. Values in-between 0 and 1 will smoothly blend the skeleton from the input pose to the results of the solver. Note: The Solver Alpha value is more efficient than the built in Alpha value that all Unreal AnimGraph nodes provide. The default Alpha value blends the resulting pose on each bone. Whereas the Solver Alpha value blends only the effectors values in the solver itself; saving the cost of blending on all the bones. Level of Detail The effect of Power IK on your skeletons may not be visible at a distance. Therefore it is wise blend the effect off when the distance to the skeleton exceeds your LOD threshold. This allows you to only pay the cost of Power IK where it matters most. Every game engine and software has it's own requirements for determining when and how to switch between levels of detail. Power IK merely provides the hooks to blend itself off, using the Solver Alpha value. It's up to you to determine when to do that. Note: If desired, you could also dynamically adjust the solver iterations based on the LOD. Power IK supports dynamically adjusting iterations. Profiling Power IK Power IK's core algorithms are very efficient and getting faster with each release. But regardless, it\u2019s always important to understand exactly what it costs to run. While playing a development build or with Play in Editor, you can execute the command: stat anim This will bring up a detailed breakdown of the animation performance in any given scenario. Power IK adds two entries into this list, Power IK Total and Power IK Solve .","title":"Solver Performance"},{"location":"unreal/solver_performance/#solver-performance","text":"Power IK uses a proprietary iterative solver that can generate nice looking poses with remarkably few iterations compared to standard IK solutions. That said, you should be aware of the performance implications of using Power IK. Especially on resource constrained devices like mobile CPUs.","title":"Solver Performance"},{"location":"unreal/solver_performance/#iterations","text":"The primary means of controlling the cost of Power IK is to adjust the number of Squash and Stretch iterations. Both default to 6 iterations each. It is unlikely that you will need more iterations than this. Though depending on the complexity of your skeleton, you may be able to get away with less. Max Squash Iterations : This is the number of iterations that the solver computes when squashing a limb. Typically, this can be left at the default. Though higher iterations may help with long complex limbs that have many bones . Max Stretch Iterations : Set this as low as you can before your effectors stop reaching their targets, or if your chain forms kinks or wobbles. A value of 6 is typically good enough even for complex chains. Note: these settings can affect performance. You should always reduce the iterations as much as you can while maintaining good results.","title":"Iterations"},{"location":"unreal/solver_performance/#solver-alpha","text":"Power IK can be smoothly blended on/off with the Solver Alpha input. This value ranges from 0-1. At zero, Power IK will shut off completely . So this can be used as a simple way of disabling the solver completely. Values in-between 0 and 1 will smoothly blend the skeleton from the input pose to the results of the solver. Note: The Solver Alpha value is more efficient than the built in Alpha value that all Unreal AnimGraph nodes provide. The default Alpha value blends the resulting pose on each bone. Whereas the Solver Alpha value blends only the effectors values in the solver itself; saving the cost of blending on all the bones.","title":"Solver Alpha"},{"location":"unreal/solver_performance/#level-of-detail","text":"The effect of Power IK on your skeletons may not be visible at a distance. Therefore it is wise blend the effect off when the distance to the skeleton exceeds your LOD threshold. This allows you to only pay the cost of Power IK where it matters most. Every game engine and software has it's own requirements for determining when and how to switch between levels of detail. Power IK merely provides the hooks to blend itself off, using the Solver Alpha value. It's up to you to determine when to do that. Note: If desired, you could also dynamically adjust the solver iterations based on the LOD. Power IK supports dynamically adjusting iterations.","title":"Level of Detail"},{"location":"unreal/solver_performance/#profiling-power-ik","text":"Power IK's core algorithms are very efficient and getting faster with each release. But regardless, it\u2019s always important to understand exactly what it costs to run. While playing a development build or with Play in Editor, you can execute the command: stat anim This will bring up a detailed breakdown of the animation performance in any given scenario. Power IK adds two entries into this list, Power IK Total and Power IK Solve .","title":"Profiling Power IK"},{"location":"unreal/solver_setup/","text":"Power IK Solver Node What Is a Power IK Solver? The core of the plugin is the Power IK solver Animation Graph node. It takes an input pose and a list of effectors . The effectors come with target transforms corresponding to joints in the skeleton. Translating or rotating an effector pulls the affected joint, with its surrounding skeleton, towards the effector transform. The solver calculates the pose to reach the affected bones towards the new set of locations. Basic Solver Setup Right-click in your animation graph and create a Power IK Solver node. Set the name of the Character Root and Ground Plane Bone. See the Bone Name Settings for explanations of these fields. In the details panel, click the \u201c+\u201d icon to add as many effectors as you need. Right-click on the Power IK Solver and click Refresh Node to make the effector pins visible in the graph. Drag off the pins to create Power IK Effector nodes. Set the Bone name of the effectors. Typically these are foot joints, but they can be any bone in the body. Connect the input pose and the output pose to the solver node. Compile the animation blueprint. Select the solver node. If everything is setup correctly, you should see yellow diamonds where your effectors are located. From here you are ready to drive the effector positions and rotations to pull the skeleton as desired. See the section on Power IK Effectors for more info. Note on Blueprint Preview Window The Power IK solver node will not affect your skeleton in the animation blueprint preview window. Typically, the effector inputs require runtime information. So the solver evaluates only while playing in editor, or in a final build.","title":"Solver Setup"},{"location":"unreal/solver_setup/#power-ik-solver-node","text":"","title":"Power IK Solver Node"},{"location":"unreal/solver_setup/#what-is-a-power-ik-solver","text":"The core of the plugin is the Power IK solver Animation Graph node. It takes an input pose and a list of effectors . The effectors come with target transforms corresponding to joints in the skeleton. Translating or rotating an effector pulls the affected joint, with its surrounding skeleton, towards the effector transform. The solver calculates the pose to reach the affected bones towards the new set of locations.","title":"What Is a Power IK Solver?"},{"location":"unreal/solver_setup/#basic-solver-setup","text":"Right-click in your animation graph and create a Power IK Solver node. Set the name of the Character Root and Ground Plane Bone. See the Bone Name Settings for explanations of these fields. In the details panel, click the \u201c+\u201d icon to add as many effectors as you need. Right-click on the Power IK Solver and click Refresh Node to make the effector pins visible in the graph. Drag off the pins to create Power IK Effector nodes. Set the Bone name of the effectors. Typically these are foot joints, but they can be any bone in the body. Connect the input pose and the output pose to the solver node. Compile the animation blueprint. Select the solver node. If everything is setup correctly, you should see yellow diamonds where your effectors are located. From here you are ready to drive the effector positions and rotations to pull the skeleton as desired. See the section on Power IK Effectors for more info.","title":"Basic Solver Setup"},{"location":"unreal/solver_setup/#note-on-blueprint-preview-window","text":"The Power IK solver node will not affect your skeleton in the animation blueprint preview window. Typically, the effector inputs require runtime information. So the solver evaluates only while playing in editor, or in a final build.","title":"Note on Blueprint Preview Window"}]}